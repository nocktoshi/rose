// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: nockchain/common/v2/blockchain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  Name,
  Note as Note1,
  SchnorrSignature,
  Signature,
  Source,
  TimeLockRangeAbsolute,
  TimeLockRangeRelative,
} from "../v1/blockchain";
import { PageResponse } from "../v1/pagination";
import { BlockHeight, Hash, Nicks, NoteVersion, SchnorrPubkey } from "../v1/primitives";

export const protobufPackage = "nockchain.common.v2";

export interface Balance {
  notes: BalanceEntry[];
  height: BlockHeight | undefined;
  blockId?: Hash | undefined;
  page: PageResponse | undefined;
}

export interface BalanceEntry {
  name: Name | undefined;
  note: Note | undefined;
}

export interface Note {
  legacy?: Note1 | undefined;
  v1?: NoteV1 | undefined;
}

export interface NoteV1 {
  version: NoteVersion | undefined;
  originPage: BlockHeight | undefined;
  name: Name | undefined;
  noteData: NoteData | undefined;
  assets: Nicks | undefined;
}

export interface NoteData {
  entries: NoteDataEntry[];
}

export interface NoteDataEntry {
  key: string;
  /** jammed noun bytes */
  blob: Uint8Array;
}

export interface RawTransaction {
  version: NoteVersion | undefined;
  id: Hash | undefined;
  spends: SpendEntry[];
}

export interface SpendEntry {
  name: Name | undefined;
  spend: Spend | undefined;
}

export interface Spend {
  legacy?: LegacySpend | undefined;
  witness?: WitnessSpend | undefined;
}

export interface LegacySpend {
  signature: Signature | undefined;
  seeds: Seed[];
  fee: Nicks | undefined;
}

export interface WitnessSpend {
  witness: Witness | undefined;
  seeds: Seed[];
  fee: Nicks | undefined;
}

export interface Seed {
  /** Absent when the seed originates from a coinbase output. */
  outputSource: Source | undefined;
  lockRoot: Hash | undefined;
  noteData: NoteData | undefined;
  gift: Nicks | undefined;
  parentHash: Hash | undefined;
}

export interface Witness {
  lockMerkleProof: LockMerkleProof | undefined;
  pkhSignature:
    | PkhSignature
    | undefined;
  /** uint64 tim = 4; // reserved field, currently 0 */
  hax: HaxPreimage[];
}

export interface HaxPreimage {
  hash:
    | Hash
    | undefined;
  /** jammed noun bytes */
  value: Uint8Array;
}

export interface PkhSignature {
  entries: PkhSignatureEntry[];
}

export interface PkhSignatureEntry {
  hash: Hash | undefined;
  pubkey: SchnorrPubkey | undefined;
  signature: SchnorrSignature | undefined;
}

export interface LockMerkleProof {
  spendCondition: SpendCondition | undefined;
  axis: number;
  proof: MerkleProof | undefined;
}

export interface SpendCondition {
  primitives: LockPrimitive[];
}

export interface LockPrimitive {
  pkh?: PkhLock | undefined;
  tim?: LockTim | undefined;
  hax?: HaxLock | undefined;
  burn?: BurnLock | undefined;
}

export interface PkhLock {
  m: number;
  hashes: Hash[];
}

export interface LockTim {
  rel: TimeLockRangeRelative | undefined;
  abs: TimeLockRangeAbsolute | undefined;
}

export interface HaxLock {
  hashes: Hash[];
}

export interface BurnLock {
}

export interface MerkleProof {
  root: Hash | undefined;
  path: Hash[];
}

function createBaseBalance(): Balance {
  return { notes: [], height: undefined, blockId: undefined, page: undefined };
}

export const Balance: MessageFns<Balance> = {
  encode(message: Balance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notes) {
      BalanceEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.height !== undefined) {
      BlockHeight.encode(message.height, writer.uint32(18).fork()).join();
    }
    if (message.blockId !== undefined) {
      Hash.encode(message.blockId, writer.uint32(26).fork()).join();
    }
    if (message.page !== undefined) {
      PageResponse.encode(message.page, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Balance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notes.push(BalanceEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.height = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockId = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.page = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Balance {
    return {
      notes: globalThis.Array.isArray(object?.notes) ? object.notes.map((e: any) => BalanceEntry.fromJSON(e)) : [],
      height: isSet(object.height) ? BlockHeight.fromJSON(object.height) : undefined,
      blockId: isSet(object.blockId) ? Hash.fromJSON(object.blockId) : undefined,
      page: isSet(object.page) ? PageResponse.fromJSON(object.page) : undefined,
    };
  },

  toJSON(message: Balance): unknown {
    const obj: any = {};
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => BalanceEntry.toJSON(e));
    }
    if (message.height !== undefined) {
      obj.height = BlockHeight.toJSON(message.height);
    }
    if (message.blockId !== undefined) {
      obj.blockId = Hash.toJSON(message.blockId);
    }
    if (message.page !== undefined) {
      obj.page = PageResponse.toJSON(message.page);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Balance>, I>>(base?: I): Balance {
    return Balance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Balance>, I>>(object: I): Balance {
    const message = createBaseBalance();
    message.notes = object.notes?.map((e) => BalanceEntry.fromPartial(e)) || [];
    message.height = (object.height !== undefined && object.height !== null)
      ? BlockHeight.fromPartial(object.height)
      : undefined;
    message.blockId = (object.blockId !== undefined && object.blockId !== null)
      ? Hash.fromPartial(object.blockId)
      : undefined;
    message.page = (object.page !== undefined && object.page !== null)
      ? PageResponse.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBaseBalanceEntry(): BalanceEntry {
  return { name: undefined, note: undefined };
}

export const BalanceEntry: MessageFns<BalanceEntry> = {
  encode(message: BalanceEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceEntry {
    return {
      name: isSet(object.name) ? Name.fromJSON(object.name) : undefined,
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
    };
  },

  toJSON(message: BalanceEntry): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = Name.toJSON(message.name);
    }
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceEntry>, I>>(base?: I): BalanceEntry {
    return BalanceEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceEntry>, I>>(object: I): BalanceEntry {
    const message = createBaseBalanceEntry();
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    return message;
  },
};

function createBaseNote(): Note {
  return { legacy: undefined, v1: undefined };
}

export const Note: MessageFns<Note> = {
  encode(message: Note, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.legacy !== undefined) {
      Note1.encode(message.legacy, writer.uint32(10).fork()).join();
    }
    if (message.v1 !== undefined) {
      NoteV1.encode(message.v1, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Note {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.legacy = Note1.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.v1 = NoteV1.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Note {
    return {
      legacy: isSet(object.legacy) ? Note1.fromJSON(object.legacy) : undefined,
      v1: isSet(object.v1) ? NoteV1.fromJSON(object.v1) : undefined,
    };
  },

  toJSON(message: Note): unknown {
    const obj: any = {};
    if (message.legacy !== undefined) {
      obj.legacy = Note1.toJSON(message.legacy);
    }
    if (message.v1 !== undefined) {
      obj.v1 = NoteV1.toJSON(message.v1);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Note>, I>>(base?: I): Note {
    return Note.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Note>, I>>(object: I): Note {
    const message = createBaseNote();
    message.legacy = (object.legacy !== undefined && object.legacy !== null)
      ? Note1.fromPartial(object.legacy)
      : undefined;
    message.v1 = (object.v1 !== undefined && object.v1 !== null) ? NoteV1.fromPartial(object.v1) : undefined;
    return message;
  },
};

function createBaseNoteV1(): NoteV1 {
  return { version: undefined, originPage: undefined, name: undefined, noteData: undefined, assets: undefined };
}

export const NoteV1: MessageFns<NoteV1> = {
  encode(message: NoteV1, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      NoteVersion.encode(message.version, writer.uint32(10).fork()).join();
    }
    if (message.originPage !== undefined) {
      BlockHeight.encode(message.originPage, writer.uint32(18).fork()).join();
    }
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(26).fork()).join();
    }
    if (message.noteData !== undefined) {
      NoteData.encode(message.noteData, writer.uint32(34).fork()).join();
    }
    if (message.assets !== undefined) {
      Nicks.encode(message.assets, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteV1 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = NoteVersion.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originPage = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.noteData = NoteData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assets = Nicks.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteV1 {
    return {
      version: isSet(object.version) ? NoteVersion.fromJSON(object.version) : undefined,
      originPage: isSet(object.originPage) ? BlockHeight.fromJSON(object.originPage) : undefined,
      name: isSet(object.name) ? Name.fromJSON(object.name) : undefined,
      noteData: isSet(object.noteData) ? NoteData.fromJSON(object.noteData) : undefined,
      assets: isSet(object.assets) ? Nicks.fromJSON(object.assets) : undefined,
    };
  },

  toJSON(message: NoteV1): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = NoteVersion.toJSON(message.version);
    }
    if (message.originPage !== undefined) {
      obj.originPage = BlockHeight.toJSON(message.originPage);
    }
    if (message.name !== undefined) {
      obj.name = Name.toJSON(message.name);
    }
    if (message.noteData !== undefined) {
      obj.noteData = NoteData.toJSON(message.noteData);
    }
    if (message.assets !== undefined) {
      obj.assets = Nicks.toJSON(message.assets);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteV1>, I>>(base?: I): NoteV1 {
    return NoteV1.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteV1>, I>>(object: I): NoteV1 {
    const message = createBaseNoteV1();
    message.version = (object.version !== undefined && object.version !== null)
      ? NoteVersion.fromPartial(object.version)
      : undefined;
    message.originPage = (object.originPage !== undefined && object.originPage !== null)
      ? BlockHeight.fromPartial(object.originPage)
      : undefined;
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.noteData = (object.noteData !== undefined && object.noteData !== null)
      ? NoteData.fromPartial(object.noteData)
      : undefined;
    message.assets = (object.assets !== undefined && object.assets !== null)
      ? Nicks.fromPartial(object.assets)
      : undefined;
    return message;
  },
};

function createBaseNoteData(): NoteData {
  return { entries: [] };
}

export const NoteData: MessageFns<NoteData> = {
  encode(message: NoteData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      NoteDataEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(NoteDataEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteData {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => NoteDataEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NoteData): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => NoteDataEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteData>, I>>(base?: I): NoteData {
    return NoteData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteData>, I>>(object: I): NoteData {
    const message = createBaseNoteData();
    message.entries = object.entries?.map((e) => NoteDataEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNoteDataEntry(): NoteDataEntry {
  return { key: "", blob: new Uint8Array(0) };
}

export const NoteDataEntry: MessageFns<NoteDataEntry> = {
  encode(message: NoteDataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.blob.length !== 0) {
      writer.uint32(18).bytes(message.blob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blob = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteDataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      blob: isSet(object.blob) ? bytesFromBase64(object.blob) : new Uint8Array(0),
    };
  },

  toJSON(message: NoteDataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.blob.length !== 0) {
      obj.blob = base64FromBytes(message.blob);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteDataEntry>, I>>(base?: I): NoteDataEntry {
    return NoteDataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteDataEntry>, I>>(object: I): NoteDataEntry {
    const message = createBaseNoteDataEntry();
    message.key = object.key ?? "";
    message.blob = object.blob ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRawTransaction(): RawTransaction {
  return { version: undefined, id: undefined, spends: [] };
}

export const RawTransaction: MessageFns<RawTransaction> = {
  encode(message: RawTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      NoteVersion.encode(message.version, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      Hash.encode(message.id, writer.uint32(18).fork()).join();
    }
    for (const v of message.spends) {
      SpendEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = NoteVersion.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.spends.push(SpendEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawTransaction {
    return {
      version: isSet(object.version) ? NoteVersion.fromJSON(object.version) : undefined,
      id: isSet(object.id) ? Hash.fromJSON(object.id) : undefined,
      spends: globalThis.Array.isArray(object?.spends) ? object.spends.map((e: any) => SpendEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: RawTransaction): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = NoteVersion.toJSON(message.version);
    }
    if (message.id !== undefined) {
      obj.id = Hash.toJSON(message.id);
    }
    if (message.spends?.length) {
      obj.spends = message.spends.map((e) => SpendEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RawTransaction>, I>>(base?: I): RawTransaction {
    return RawTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RawTransaction>, I>>(object: I): RawTransaction {
    const message = createBaseRawTransaction();
    message.version = (object.version !== undefined && object.version !== null)
      ? NoteVersion.fromPartial(object.version)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? Hash.fromPartial(object.id) : undefined;
    message.spends = object.spends?.map((e) => SpendEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpendEntry(): SpendEntry {
  return { name: undefined, spend: undefined };
}

export const SpendEntry: MessageFns<SpendEntry> = {
  encode(message: SpendEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.spend !== undefined) {
      Spend.encode(message.spend, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpendEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.spend = Spend.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpendEntry {
    return {
      name: isSet(object.name) ? Name.fromJSON(object.name) : undefined,
      spend: isSet(object.spend) ? Spend.fromJSON(object.spend) : undefined,
    };
  },

  toJSON(message: SpendEntry): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = Name.toJSON(message.name);
    }
    if (message.spend !== undefined) {
      obj.spend = Spend.toJSON(message.spend);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendEntry>, I>>(base?: I): SpendEntry {
    return SpendEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendEntry>, I>>(object: I): SpendEntry {
    const message = createBaseSpendEntry();
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.spend = (object.spend !== undefined && object.spend !== null) ? Spend.fromPartial(object.spend) : undefined;
    return message;
  },
};

function createBaseSpend(): Spend {
  return { legacy: undefined, witness: undefined };
}

export const Spend: MessageFns<Spend> = {
  encode(message: Spend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.legacy !== undefined) {
      LegacySpend.encode(message.legacy, writer.uint32(10).fork()).join();
    }
    if (message.witness !== undefined) {
      WitnessSpend.encode(message.witness, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.legacy = LegacySpend.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.witness = WitnessSpend.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spend {
    return {
      legacy: isSet(object.legacy) ? LegacySpend.fromJSON(object.legacy) : undefined,
      witness: isSet(object.witness) ? WitnessSpend.fromJSON(object.witness) : undefined,
    };
  },

  toJSON(message: Spend): unknown {
    const obj: any = {};
    if (message.legacy !== undefined) {
      obj.legacy = LegacySpend.toJSON(message.legacy);
    }
    if (message.witness !== undefined) {
      obj.witness = WitnessSpend.toJSON(message.witness);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spend>, I>>(base?: I): Spend {
    return Spend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spend>, I>>(object: I): Spend {
    const message = createBaseSpend();
    message.legacy = (object.legacy !== undefined && object.legacy !== null)
      ? LegacySpend.fromPartial(object.legacy)
      : undefined;
    message.witness = (object.witness !== undefined && object.witness !== null)
      ? WitnessSpend.fromPartial(object.witness)
      : undefined;
    return message;
  },
};

function createBaseLegacySpend(): LegacySpend {
  return { signature: undefined, seeds: [], fee: undefined };
}

export const LegacySpend: MessageFns<LegacySpend> = {
  encode(message: LegacySpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(10).fork()).join();
    }
    for (const v of message.seeds) {
      Seed.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.fee !== undefined) {
      Nicks.encode(message.fee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LegacySpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLegacySpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seeds.push(Seed.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fee = Nicks.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LegacySpend {
    return {
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
      seeds: globalThis.Array.isArray(object?.seeds) ? object.seeds.map((e: any) => Seed.fromJSON(e)) : [],
      fee: isSet(object.fee) ? Nicks.fromJSON(object.fee) : undefined,
    };
  },

  toJSON(message: LegacySpend): unknown {
    const obj: any = {};
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    if (message.seeds?.length) {
      obj.seeds = message.seeds.map((e) => Seed.toJSON(e));
    }
    if (message.fee !== undefined) {
      obj.fee = Nicks.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LegacySpend>, I>>(base?: I): LegacySpend {
    return LegacySpend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LegacySpend>, I>>(object: I): LegacySpend {
    const message = createBaseLegacySpend();
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    message.seeds = object.seeds?.map((e) => Seed.fromPartial(e)) || [];
    message.fee = (object.fee !== undefined && object.fee !== null) ? Nicks.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseWitnessSpend(): WitnessSpend {
  return { witness: undefined, seeds: [], fee: undefined };
}

export const WitnessSpend: MessageFns<WitnessSpend> = {
  encode(message: WitnessSpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.witness !== undefined) {
      Witness.encode(message.witness, writer.uint32(10).fork()).join();
    }
    for (const v of message.seeds) {
      Seed.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.fee !== undefined) {
      Nicks.encode(message.fee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WitnessSpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitnessSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.witness = Witness.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seeds.push(Seed.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fee = Nicks.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WitnessSpend {
    return {
      witness: isSet(object.witness) ? Witness.fromJSON(object.witness) : undefined,
      seeds: globalThis.Array.isArray(object?.seeds) ? object.seeds.map((e: any) => Seed.fromJSON(e)) : [],
      fee: isSet(object.fee) ? Nicks.fromJSON(object.fee) : undefined,
    };
  },

  toJSON(message: WitnessSpend): unknown {
    const obj: any = {};
    if (message.witness !== undefined) {
      obj.witness = Witness.toJSON(message.witness);
    }
    if (message.seeds?.length) {
      obj.seeds = message.seeds.map((e) => Seed.toJSON(e));
    }
    if (message.fee !== undefined) {
      obj.fee = Nicks.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WitnessSpend>, I>>(base?: I): WitnessSpend {
    return WitnessSpend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WitnessSpend>, I>>(object: I): WitnessSpend {
    const message = createBaseWitnessSpend();
    message.witness = (object.witness !== undefined && object.witness !== null)
      ? Witness.fromPartial(object.witness)
      : undefined;
    message.seeds = object.seeds?.map((e) => Seed.fromPartial(e)) || [];
    message.fee = (object.fee !== undefined && object.fee !== null) ? Nicks.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseSeed(): Seed {
  return { outputSource: undefined, lockRoot: undefined, noteData: undefined, gift: undefined, parentHash: undefined };
}

export const Seed: MessageFns<Seed> = {
  encode(message: Seed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputSource !== undefined) {
      Source.encode(message.outputSource, writer.uint32(10).fork()).join();
    }
    if (message.lockRoot !== undefined) {
      Hash.encode(message.lockRoot, writer.uint32(18).fork()).join();
    }
    if (message.noteData !== undefined) {
      NoteData.encode(message.noteData, writer.uint32(26).fork()).join();
    }
    if (message.gift !== undefined) {
      Nicks.encode(message.gift, writer.uint32(34).fork()).join();
    }
    if (message.parentHash !== undefined) {
      Hash.encode(message.parentHash, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Seed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputSource = Source.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lockRoot = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.noteData = NoteData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gift = Nicks.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parentHash = Hash.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Seed {
    return {
      outputSource: isSet(object.outputSource) ? Source.fromJSON(object.outputSource) : undefined,
      lockRoot: isSet(object.lockRoot) ? Hash.fromJSON(object.lockRoot) : undefined,
      noteData: isSet(object.noteData) ? NoteData.fromJSON(object.noteData) : undefined,
      gift: isSet(object.gift) ? Nicks.fromJSON(object.gift) : undefined,
      parentHash: isSet(object.parentHash) ? Hash.fromJSON(object.parentHash) : undefined,
    };
  },

  toJSON(message: Seed): unknown {
    const obj: any = {};
    if (message.outputSource !== undefined) {
      obj.outputSource = Source.toJSON(message.outputSource);
    }
    if (message.lockRoot !== undefined) {
      obj.lockRoot = Hash.toJSON(message.lockRoot);
    }
    if (message.noteData !== undefined) {
      obj.noteData = NoteData.toJSON(message.noteData);
    }
    if (message.gift !== undefined) {
      obj.gift = Nicks.toJSON(message.gift);
    }
    if (message.parentHash !== undefined) {
      obj.parentHash = Hash.toJSON(message.parentHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Seed>, I>>(base?: I): Seed {
    return Seed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Seed>, I>>(object: I): Seed {
    const message = createBaseSeed();
    message.outputSource = (object.outputSource !== undefined && object.outputSource !== null)
      ? Source.fromPartial(object.outputSource)
      : undefined;
    message.lockRoot = (object.lockRoot !== undefined && object.lockRoot !== null)
      ? Hash.fromPartial(object.lockRoot)
      : undefined;
    message.noteData = (object.noteData !== undefined && object.noteData !== null)
      ? NoteData.fromPartial(object.noteData)
      : undefined;
    message.gift = (object.gift !== undefined && object.gift !== null) ? Nicks.fromPartial(object.gift) : undefined;
    message.parentHash = (object.parentHash !== undefined && object.parentHash !== null)
      ? Hash.fromPartial(object.parentHash)
      : undefined;
    return message;
  },
};

function createBaseWitness(): Witness {
  return { lockMerkleProof: undefined, pkhSignature: undefined, hax: [] };
}

export const Witness: MessageFns<Witness> = {
  encode(message: Witness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lockMerkleProof !== undefined) {
      LockMerkleProof.encode(message.lockMerkleProof, writer.uint32(10).fork()).join();
    }
    if (message.pkhSignature !== undefined) {
      PkhSignature.encode(message.pkhSignature, writer.uint32(18).fork()).join();
    }
    for (const v of message.hax) {
      HaxPreimage.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Witness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lockMerkleProof = LockMerkleProof.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pkhSignature = PkhSignature.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hax.push(HaxPreimage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Witness {
    return {
      lockMerkleProof: isSet(object.lockMerkleProof) ? LockMerkleProof.fromJSON(object.lockMerkleProof) : undefined,
      pkhSignature: isSet(object.pkhSignature) ? PkhSignature.fromJSON(object.pkhSignature) : undefined,
      hax: globalThis.Array.isArray(object?.hax) ? object.hax.map((e: any) => HaxPreimage.fromJSON(e)) : [],
    };
  },

  toJSON(message: Witness): unknown {
    const obj: any = {};
    if (message.lockMerkleProof !== undefined) {
      obj.lockMerkleProof = LockMerkleProof.toJSON(message.lockMerkleProof);
    }
    if (message.pkhSignature !== undefined) {
      obj.pkhSignature = PkhSignature.toJSON(message.pkhSignature);
    }
    if (message.hax?.length) {
      obj.hax = message.hax.map((e) => HaxPreimage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Witness>, I>>(base?: I): Witness {
    return Witness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Witness>, I>>(object: I): Witness {
    const message = createBaseWitness();
    message.lockMerkleProof = (object.lockMerkleProof !== undefined && object.lockMerkleProof !== null)
      ? LockMerkleProof.fromPartial(object.lockMerkleProof)
      : undefined;
    message.pkhSignature = (object.pkhSignature !== undefined && object.pkhSignature !== null)
      ? PkhSignature.fromPartial(object.pkhSignature)
      : undefined;
    message.hax = object.hax?.map((e) => HaxPreimage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHaxPreimage(): HaxPreimage {
  return { hash: undefined, value: new Uint8Array(0) };
}

export const HaxPreimage: MessageFns<HaxPreimage> = {
  encode(message: HaxPreimage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== undefined) {
      Hash.encode(message.hash, writer.uint32(10).fork()).join();
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HaxPreimage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHaxPreimage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HaxPreimage {
    return {
      hash: isSet(object.hash) ? Hash.fromJSON(object.hash) : undefined,
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: HaxPreimage): unknown {
    const obj: any = {};
    if (message.hash !== undefined) {
      obj.hash = Hash.toJSON(message.hash);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HaxPreimage>, I>>(base?: I): HaxPreimage {
    return HaxPreimage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HaxPreimage>, I>>(object: I): HaxPreimage {
    const message = createBaseHaxPreimage();
    message.hash = (object.hash !== undefined && object.hash !== null) ? Hash.fromPartial(object.hash) : undefined;
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBasePkhSignature(): PkhSignature {
  return { entries: [] };
}

export const PkhSignature: MessageFns<PkhSignature> = {
  encode(message: PkhSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      PkhSignatureEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PkhSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePkhSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(PkhSignatureEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PkhSignature {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => PkhSignatureEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PkhSignature): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => PkhSignatureEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PkhSignature>, I>>(base?: I): PkhSignature {
    return PkhSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PkhSignature>, I>>(object: I): PkhSignature {
    const message = createBasePkhSignature();
    message.entries = object.entries?.map((e) => PkhSignatureEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBasePkhSignatureEntry(): PkhSignatureEntry {
  return { hash: undefined, pubkey: undefined, signature: undefined };
}

export const PkhSignatureEntry: MessageFns<PkhSignatureEntry> = {
  encode(message: PkhSignatureEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== undefined) {
      Hash.encode(message.hash, writer.uint32(10).fork()).join();
    }
    if (message.pubkey !== undefined) {
      SchnorrPubkey.encode(message.pubkey, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      SchnorrSignature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PkhSignatureEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePkhSignatureEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pubkey = SchnorrPubkey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = SchnorrSignature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PkhSignatureEntry {
    return {
      hash: isSet(object.hash) ? Hash.fromJSON(object.hash) : undefined,
      pubkey: isSet(object.pubkey) ? SchnorrPubkey.fromJSON(object.pubkey) : undefined,
      signature: isSet(object.signature) ? SchnorrSignature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: PkhSignatureEntry): unknown {
    const obj: any = {};
    if (message.hash !== undefined) {
      obj.hash = Hash.toJSON(message.hash);
    }
    if (message.pubkey !== undefined) {
      obj.pubkey = SchnorrPubkey.toJSON(message.pubkey);
    }
    if (message.signature !== undefined) {
      obj.signature = SchnorrSignature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PkhSignatureEntry>, I>>(base?: I): PkhSignatureEntry {
    return PkhSignatureEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PkhSignatureEntry>, I>>(object: I): PkhSignatureEntry {
    const message = createBasePkhSignatureEntry();
    message.hash = (object.hash !== undefined && object.hash !== null) ? Hash.fromPartial(object.hash) : undefined;
    message.pubkey = (object.pubkey !== undefined && object.pubkey !== null)
      ? SchnorrPubkey.fromPartial(object.pubkey)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? SchnorrSignature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseLockMerkleProof(): LockMerkleProof {
  return { spendCondition: undefined, axis: 0, proof: undefined };
}

export const LockMerkleProof: MessageFns<LockMerkleProof> = {
  encode(message: LockMerkleProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spendCondition !== undefined) {
      SpendCondition.encode(message.spendCondition, writer.uint32(10).fork()).join();
    }
    if (message.axis !== 0) {
      writer.uint32(16).uint64(message.axis);
    }
    if (message.proof !== undefined) {
      MerkleProof.encode(message.proof, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockMerkleProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockMerkleProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spendCondition = SpendCondition.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.axis = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proof = MerkleProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockMerkleProof {
    return {
      spendCondition: isSet(object.spendCondition) ? SpendCondition.fromJSON(object.spendCondition) : undefined,
      axis: isSet(object.axis) ? globalThis.Number(object.axis) : 0,
      proof: isSet(object.proof) ? MerkleProof.fromJSON(object.proof) : undefined,
    };
  },

  toJSON(message: LockMerkleProof): unknown {
    const obj: any = {};
    if (message.spendCondition !== undefined) {
      obj.spendCondition = SpendCondition.toJSON(message.spendCondition);
    }
    if (message.axis !== 0) {
      obj.axis = Math.round(message.axis);
    }
    if (message.proof !== undefined) {
      obj.proof = MerkleProof.toJSON(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LockMerkleProof>, I>>(base?: I): LockMerkleProof {
    return LockMerkleProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LockMerkleProof>, I>>(object: I): LockMerkleProof {
    const message = createBaseLockMerkleProof();
    message.spendCondition = (object.spendCondition !== undefined && object.spendCondition !== null)
      ? SpendCondition.fromPartial(object.spendCondition)
      : undefined;
    message.axis = object.axis ?? 0;
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? MerkleProof.fromPartial(object.proof)
      : undefined;
    return message;
  },
};

function createBaseSpendCondition(): SpendCondition {
  return { primitives: [] };
}

export const SpendCondition: MessageFns<SpendCondition> = {
  encode(message: SpendCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.primitives) {
      LockPrimitive.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpendCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primitives.push(LockPrimitive.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpendCondition {
    return {
      primitives: globalThis.Array.isArray(object?.primitives)
        ? object.primitives.map((e: any) => LockPrimitive.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SpendCondition): unknown {
    const obj: any = {};
    if (message.primitives?.length) {
      obj.primitives = message.primitives.map((e) => LockPrimitive.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendCondition>, I>>(base?: I): SpendCondition {
    return SpendCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendCondition>, I>>(object: I): SpendCondition {
    const message = createBaseSpendCondition();
    message.primitives = object.primitives?.map((e) => LockPrimitive.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLockPrimitive(): LockPrimitive {
  return { pkh: undefined, tim: undefined, hax: undefined, burn: undefined };
}

export const LockPrimitive: MessageFns<LockPrimitive> = {
  encode(message: LockPrimitive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pkh !== undefined) {
      PkhLock.encode(message.pkh, writer.uint32(10).fork()).join();
    }
    if (message.tim !== undefined) {
      LockTim.encode(message.tim, writer.uint32(18).fork()).join();
    }
    if (message.hax !== undefined) {
      HaxLock.encode(message.hax, writer.uint32(26).fork()).join();
    }
    if (message.burn !== undefined) {
      BurnLock.encode(message.burn, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockPrimitive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockPrimitive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pkh = PkhLock.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tim = LockTim.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hax = HaxLock.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.burn = BurnLock.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockPrimitive {
    return {
      pkh: isSet(object.pkh) ? PkhLock.fromJSON(object.pkh) : undefined,
      tim: isSet(object.tim) ? LockTim.fromJSON(object.tim) : undefined,
      hax: isSet(object.hax) ? HaxLock.fromJSON(object.hax) : undefined,
      burn: isSet(object.burn) ? BurnLock.fromJSON(object.burn) : undefined,
    };
  },

  toJSON(message: LockPrimitive): unknown {
    const obj: any = {};
    if (message.pkh !== undefined) {
      obj.pkh = PkhLock.toJSON(message.pkh);
    }
    if (message.tim !== undefined) {
      obj.tim = LockTim.toJSON(message.tim);
    }
    if (message.hax !== undefined) {
      obj.hax = HaxLock.toJSON(message.hax);
    }
    if (message.burn !== undefined) {
      obj.burn = BurnLock.toJSON(message.burn);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LockPrimitive>, I>>(base?: I): LockPrimitive {
    return LockPrimitive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LockPrimitive>, I>>(object: I): LockPrimitive {
    const message = createBaseLockPrimitive();
    message.pkh = (object.pkh !== undefined && object.pkh !== null) ? PkhLock.fromPartial(object.pkh) : undefined;
    message.tim = (object.tim !== undefined && object.tim !== null) ? LockTim.fromPartial(object.tim) : undefined;
    message.hax = (object.hax !== undefined && object.hax !== null) ? HaxLock.fromPartial(object.hax) : undefined;
    message.burn = (object.burn !== undefined && object.burn !== null) ? BurnLock.fromPartial(object.burn) : undefined;
    return message;
  },
};

function createBasePkhLock(): PkhLock {
  return { m: 0, hashes: [] };
}

export const PkhLock: MessageFns<PkhLock> = {
  encode(message: PkhLock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.m !== 0) {
      writer.uint32(8).uint64(message.m);
    }
    for (const v of message.hashes) {
      Hash.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PkhLock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePkhLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.m = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hashes.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PkhLock {
    return {
      m: isSet(object.m) ? globalThis.Number(object.m) : 0,
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => Hash.fromJSON(e)) : [],
    };
  },

  toJSON(message: PkhLock): unknown {
    const obj: any = {};
    if (message.m !== 0) {
      obj.m = Math.round(message.m);
    }
    if (message.hashes?.length) {
      obj.hashes = message.hashes.map((e) => Hash.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PkhLock>, I>>(base?: I): PkhLock {
    return PkhLock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PkhLock>, I>>(object: I): PkhLock {
    const message = createBasePkhLock();
    message.m = object.m ?? 0;
    message.hashes = object.hashes?.map((e) => Hash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLockTim(): LockTim {
  return { rel: undefined, abs: undefined };
}

export const LockTim: MessageFns<LockTim> = {
  encode(message: LockTim, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rel !== undefined) {
      TimeLockRangeRelative.encode(message.rel, writer.uint32(10).fork()).join();
    }
    if (message.abs !== undefined) {
      TimeLockRangeAbsolute.encode(message.abs, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockTim {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockTim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rel = TimeLockRangeRelative.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.abs = TimeLockRangeAbsolute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockTim {
    return {
      rel: isSet(object.rel) ? TimeLockRangeRelative.fromJSON(object.rel) : undefined,
      abs: isSet(object.abs) ? TimeLockRangeAbsolute.fromJSON(object.abs) : undefined,
    };
  },

  toJSON(message: LockTim): unknown {
    const obj: any = {};
    if (message.rel !== undefined) {
      obj.rel = TimeLockRangeRelative.toJSON(message.rel);
    }
    if (message.abs !== undefined) {
      obj.abs = TimeLockRangeAbsolute.toJSON(message.abs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LockTim>, I>>(base?: I): LockTim {
    return LockTim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LockTim>, I>>(object: I): LockTim {
    const message = createBaseLockTim();
    message.rel = (object.rel !== undefined && object.rel !== null)
      ? TimeLockRangeRelative.fromPartial(object.rel)
      : undefined;
    message.abs = (object.abs !== undefined && object.abs !== null)
      ? TimeLockRangeAbsolute.fromPartial(object.abs)
      : undefined;
    return message;
  },
};

function createBaseHaxLock(): HaxLock {
  return { hashes: [] };
}

export const HaxLock: MessageFns<HaxLock> = {
  encode(message: HaxLock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hashes) {
      Hash.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HaxLock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHaxLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hashes.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HaxLock {
    return { hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => Hash.fromJSON(e)) : [] };
  },

  toJSON(message: HaxLock): unknown {
    const obj: any = {};
    if (message.hashes?.length) {
      obj.hashes = message.hashes.map((e) => Hash.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HaxLock>, I>>(base?: I): HaxLock {
    return HaxLock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HaxLock>, I>>(object: I): HaxLock {
    const message = createBaseHaxLock();
    message.hashes = object.hashes?.map((e) => Hash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBurnLock(): BurnLock {
  return {};
}

export const BurnLock: MessageFns<BurnLock> = {
  encode(_: BurnLock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BurnLock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBurnLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BurnLock {
    return {};
  },

  toJSON(_: BurnLock): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BurnLock>, I>>(base?: I): BurnLock {
    return BurnLock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BurnLock>, I>>(_: I): BurnLock {
    const message = createBaseBurnLock();
    return message;
  },
};

function createBaseMerkleProof(): MerkleProof {
  return { root: undefined, path: [] };
}

export const MerkleProof: MessageFns<MerkleProof> = {
  encode(message: MerkleProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.root !== undefined) {
      Hash.encode(message.root, writer.uint32(10).fork()).join();
    }
    for (const v of message.path) {
      Hash.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MerkleProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerkleProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.root = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MerkleProof {
    return {
      root: isSet(object.root) ? Hash.fromJSON(object.root) : undefined,
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => Hash.fromJSON(e)) : [],
    };
  },

  toJSON(message: MerkleProof): unknown {
    const obj: any = {};
    if (message.root !== undefined) {
      obj.root = Hash.toJSON(message.root);
    }
    if (message.path?.length) {
      obj.path = message.path.map((e) => Hash.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MerkleProof>, I>>(base?: I): MerkleProof {
    return MerkleProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MerkleProof>, I>>(object: I): MerkleProof {
    const message = createBaseMerkleProof();
    message.root = (object.root !== undefined && object.root !== null) ? Hash.fromPartial(object.root) : undefined;
    message.path = object.path?.map((e) => Hash.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
