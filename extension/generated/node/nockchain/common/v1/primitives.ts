// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: nockchain/common/v1/primitives.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "nockchain.common.v1";

export enum ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0,
  ERROR_CODE_INVALID_REQUEST = 1,
  ERROR_CODE_PEEK_FAILED = 2,
  ERROR_CODE_PEEK_RETURNED_NO_DATA = 3,
  ERROR_CODE_POKE_FAILED = 4,
  ERROR_CODE_NACKAPP_ERROR = 5,
  ERROR_CODE_TIMEOUT = 6,
  ERROR_CODE_INTERNAL_ERROR = 7,
  ERROR_CODE_NOT_FOUND = 8,
  ERROR_CODE_PERMISSION_DENIED = 9,
  ERROR_CODE_INVALID_WIRE = 10,
  ERROR_CODE_KERNEL_ERROR = 11,
  UNRECOGNIZED = -1,
}

export interface ErrorStatus {
  code: ErrorCode;
  message: string;
  /** additional error context */
  details?: string | undefined;
}

export interface Acknowledged {
}

export interface Wire {
  /** e.g., "http", "file", "wallet", "grpc" */
  source: string;
  /** wire format version */
  version: string;
  /** operation-specific tags */
  tags: WireTag[];
}

export interface WireTag {
  text?: string | undefined;
  number?: string | undefined;
}

/**
 * Note: prefer using raw numeric fields in messages
 * instead of these wrappers to simplify conversions.
 * These remain defined for potential future use.
 */
export interface NoteVersion {
  value: number;
}

export interface BlockHeight {
  value: string;
}

export interface BlockHeightDelta {
  value: string;
}

export interface Nicks {
  value: string;
}

/**
 * pub chal: [Belt; 8],
 * pub sig: [Belt; 8],
 */
export interface EightBelt {
  belt1: Belt | undefined;
  belt2: Belt | undefined;
  belt3: Belt | undefined;
  belt4: Belt | undefined;
  belt5: Belt | undefined;
  belt6: Belt | undefined;
  belt7: Belt | undefined;
  belt8: Belt | undefined;
}

/**
 * pub struct Hash(pub [Belt; 5]);
 * Use fixed fields to avoid variable-length vectors.
 */
export interface Hash {
  belt1: Belt | undefined;
  belt2: Belt | undefined;
  belt3: Belt | undefined;
  belt4: Belt | undefined;
  belt5: Belt | undefined;
}

export interface Base58Hash {
  hash: string;
}

export interface Base58Pubkey {
  key: string;
}

/** pub struct SchnorrPubkey(pub CheetahPoint); */
export interface SchnorrPubkey {
  value: CheetahPoint | undefined;
}

/**
 * pub struct CheetahPoint {
 *   pub x: F6lt,
 *   pub y: F6lt,
 *   pub inf: bool,
 * }
 */
export interface CheetahPoint {
  x: SixBelt | undefined;
  y: SixBelt | undefined;
  inf: boolean;
}

/** pub struct F6lt(pub [Belt; 6]); */
export interface SixBelt {
  belt1: Belt | undefined;
  belt2: Belt | undefined;
  belt3: Belt | undefined;
  belt4: Belt | undefined;
  belt5: Belt | undefined;
  belt6: Belt | undefined;
}

/** pub struct Belt(pub u64); */
export interface Belt {
  value: string;
}

function createBaseErrorStatus(): ErrorStatus {
  return { code: 0, message: "", details: undefined };
}

export const ErrorStatus: MessageFns<ErrorStatus> = {
  encode(message: ErrorStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== undefined) {
      writer.uint32(26).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ErrorStatus>): ErrorStatus {
    return ErrorStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorStatus>): ErrorStatus {
    const message = createBaseErrorStatus();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.details = object.details ?? undefined;
    return message;
  },
};

function createBaseAcknowledged(): Acknowledged {
  return {};
}

export const Acknowledged: MessageFns<Acknowledged> = {
  encode(_: Acknowledged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Acknowledged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Acknowledged>): Acknowledged {
    return Acknowledged.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Acknowledged>): Acknowledged {
    const message = createBaseAcknowledged();
    return message;
  },
};

function createBaseWire(): Wire {
  return { source: "", version: "0", tags: [] };
}

export const Wire: MessageFns<Wire> = {
  encode(message: Wire, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.version !== "0") {
      writer.uint32(16).uint64(message.version);
    }
    for (const v of message.tags) {
      WireTag.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wire {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWire();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tags.push(WireTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Wire>): Wire {
    return Wire.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Wire>): Wire {
    const message = createBaseWire();
    message.source = object.source ?? "";
    message.version = object.version ?? "0";
    message.tags = object.tags?.map((e) => WireTag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWireTag(): WireTag {
  return { text: undefined, number: undefined };
}

export const WireTag: MessageFns<WireTag> = {
  encode(message: WireTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(10).string(message.text);
    }
    if (message.number !== undefined) {
      writer.uint32(16).uint64(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.number = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WireTag>): WireTag {
    return WireTag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WireTag>): WireTag {
    const message = createBaseWireTag();
    message.text = object.text ?? undefined;
    message.number = object.number ?? undefined;
    return message;
  },
};

function createBaseNoteVersion(): NoteVersion {
  return { value: 0 };
}

export const NoteVersion: MessageFns<NoteVersion> = {
  encode(message: NoteVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NoteVersion>): NoteVersion {
    return NoteVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoteVersion>): NoteVersion {
    const message = createBaseNoteVersion();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseBlockHeight(): BlockHeight {
  return { value: "0" };
}

export const BlockHeight: MessageFns<BlockHeight> = {
  encode(message: BlockHeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "0") {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlockHeight>): BlockHeight {
    return BlockHeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeight>): BlockHeight {
    const message = createBaseBlockHeight();
    message.value = object.value ?? "0";
    return message;
  },
};

function createBaseBlockHeightDelta(): BlockHeightDelta {
  return { value: "0" };
}

export const BlockHeightDelta: MessageFns<BlockHeightDelta> = {
  encode(message: BlockHeightDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "0") {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeightDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeightDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BlockHeightDelta>): BlockHeightDelta {
    return BlockHeightDelta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeightDelta>): BlockHeightDelta {
    const message = createBaseBlockHeightDelta();
    message.value = object.value ?? "0";
    return message;
  },
};

function createBaseNicks(): Nicks {
  return { value: "0" };
}

export const Nicks: MessageFns<Nicks> = {
  encode(message: Nicks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "0") {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Nicks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNicks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Nicks>): Nicks {
    return Nicks.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Nicks>): Nicks {
    const message = createBaseNicks();
    message.value = object.value ?? "0";
    return message;
  },
};

function createBaseEightBelt(): EightBelt {
  return {
    belt1: undefined,
    belt2: undefined,
    belt3: undefined,
    belt4: undefined,
    belt5: undefined,
    belt6: undefined,
    belt7: undefined,
    belt8: undefined,
  };
}

export const EightBelt: MessageFns<EightBelt> = {
  encode(message: EightBelt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.belt1 !== undefined) {
      Belt.encode(message.belt1, writer.uint32(10).fork()).join();
    }
    if (message.belt2 !== undefined) {
      Belt.encode(message.belt2, writer.uint32(18).fork()).join();
    }
    if (message.belt3 !== undefined) {
      Belt.encode(message.belt3, writer.uint32(26).fork()).join();
    }
    if (message.belt4 !== undefined) {
      Belt.encode(message.belt4, writer.uint32(34).fork()).join();
    }
    if (message.belt5 !== undefined) {
      Belt.encode(message.belt5, writer.uint32(42).fork()).join();
    }
    if (message.belt6 !== undefined) {
      Belt.encode(message.belt6, writer.uint32(50).fork()).join();
    }
    if (message.belt7 !== undefined) {
      Belt.encode(message.belt7, writer.uint32(58).fork()).join();
    }
    if (message.belt8 !== undefined) {
      Belt.encode(message.belt8, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EightBelt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEightBelt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.belt1 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.belt2 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.belt3 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.belt4 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.belt5 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.belt6 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.belt7 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.belt8 = Belt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EightBelt>): EightBelt {
    return EightBelt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EightBelt>): EightBelt {
    const message = createBaseEightBelt();
    message.belt1 = (object.belt1 !== undefined && object.belt1 !== null) ? Belt.fromPartial(object.belt1) : undefined;
    message.belt2 = (object.belt2 !== undefined && object.belt2 !== null) ? Belt.fromPartial(object.belt2) : undefined;
    message.belt3 = (object.belt3 !== undefined && object.belt3 !== null) ? Belt.fromPartial(object.belt3) : undefined;
    message.belt4 = (object.belt4 !== undefined && object.belt4 !== null) ? Belt.fromPartial(object.belt4) : undefined;
    message.belt5 = (object.belt5 !== undefined && object.belt5 !== null) ? Belt.fromPartial(object.belt5) : undefined;
    message.belt6 = (object.belt6 !== undefined && object.belt6 !== null) ? Belt.fromPartial(object.belt6) : undefined;
    message.belt7 = (object.belt7 !== undefined && object.belt7 !== null) ? Belt.fromPartial(object.belt7) : undefined;
    message.belt8 = (object.belt8 !== undefined && object.belt8 !== null) ? Belt.fromPartial(object.belt8) : undefined;
    return message;
  },
};

function createBaseHash(): Hash {
  return { belt1: undefined, belt2: undefined, belt3: undefined, belt4: undefined, belt5: undefined };
}

export const Hash: MessageFns<Hash> = {
  encode(message: Hash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.belt1 !== undefined) {
      Belt.encode(message.belt1, writer.uint32(10).fork()).join();
    }
    if (message.belt2 !== undefined) {
      Belt.encode(message.belt2, writer.uint32(18).fork()).join();
    }
    if (message.belt3 !== undefined) {
      Belt.encode(message.belt3, writer.uint32(26).fork()).join();
    }
    if (message.belt4 !== undefined) {
      Belt.encode(message.belt4, writer.uint32(34).fork()).join();
    }
    if (message.belt5 !== undefined) {
      Belt.encode(message.belt5, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.belt1 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.belt2 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.belt3 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.belt4 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.belt5 = Belt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Hash>): Hash {
    return Hash.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hash>): Hash {
    const message = createBaseHash();
    message.belt1 = (object.belt1 !== undefined && object.belt1 !== null) ? Belt.fromPartial(object.belt1) : undefined;
    message.belt2 = (object.belt2 !== undefined && object.belt2 !== null) ? Belt.fromPartial(object.belt2) : undefined;
    message.belt3 = (object.belt3 !== undefined && object.belt3 !== null) ? Belt.fromPartial(object.belt3) : undefined;
    message.belt4 = (object.belt4 !== undefined && object.belt4 !== null) ? Belt.fromPartial(object.belt4) : undefined;
    message.belt5 = (object.belt5 !== undefined && object.belt5 !== null) ? Belt.fromPartial(object.belt5) : undefined;
    return message;
  },
};

function createBaseBase58Hash(): Base58Hash {
  return { hash: "" };
}

export const Base58Hash: MessageFns<Base58Hash> = {
  encode(message: Base58Hash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Base58Hash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBase58Hash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Base58Hash>): Base58Hash {
    return Base58Hash.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Base58Hash>): Base58Hash {
    const message = createBaseBase58Hash();
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseBase58Pubkey(): Base58Pubkey {
  return { key: "" };
}

export const Base58Pubkey: MessageFns<Base58Pubkey> = {
  encode(message: Base58Pubkey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Base58Pubkey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBase58Pubkey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Base58Pubkey>): Base58Pubkey {
    return Base58Pubkey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Base58Pubkey>): Base58Pubkey {
    const message = createBaseBase58Pubkey();
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseSchnorrPubkey(): SchnorrPubkey {
  return { value: undefined };
}

export const SchnorrPubkey: MessageFns<SchnorrPubkey> = {
  encode(message: SchnorrPubkey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      CheetahPoint.encode(message.value, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchnorrPubkey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchnorrPubkey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = CheetahPoint.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SchnorrPubkey>): SchnorrPubkey {
    return SchnorrPubkey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchnorrPubkey>): SchnorrPubkey {
    const message = createBaseSchnorrPubkey();
    message.value = (object.value !== undefined && object.value !== null)
      ? CheetahPoint.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCheetahPoint(): CheetahPoint {
  return { x: undefined, y: undefined, inf: false };
}

export const CheetahPoint: MessageFns<CheetahPoint> = {
  encode(message: CheetahPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== undefined) {
      SixBelt.encode(message.x, writer.uint32(10).fork()).join();
    }
    if (message.y !== undefined) {
      SixBelt.encode(message.y, writer.uint32(18).fork()).join();
    }
    if (message.inf !== false) {
      writer.uint32(24).bool(message.inf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheetahPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheetahPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.x = SixBelt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.y = SixBelt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inf = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CheetahPoint>): CheetahPoint {
    return CheetahPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheetahPoint>): CheetahPoint {
    const message = createBaseCheetahPoint();
    message.x = (object.x !== undefined && object.x !== null) ? SixBelt.fromPartial(object.x) : undefined;
    message.y = (object.y !== undefined && object.y !== null) ? SixBelt.fromPartial(object.y) : undefined;
    message.inf = object.inf ?? false;
    return message;
  },
};

function createBaseSixBelt(): SixBelt {
  return { belt1: undefined, belt2: undefined, belt3: undefined, belt4: undefined, belt5: undefined, belt6: undefined };
}

export const SixBelt: MessageFns<SixBelt> = {
  encode(message: SixBelt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.belt1 !== undefined) {
      Belt.encode(message.belt1, writer.uint32(10).fork()).join();
    }
    if (message.belt2 !== undefined) {
      Belt.encode(message.belt2, writer.uint32(18).fork()).join();
    }
    if (message.belt3 !== undefined) {
      Belt.encode(message.belt3, writer.uint32(26).fork()).join();
    }
    if (message.belt4 !== undefined) {
      Belt.encode(message.belt4, writer.uint32(34).fork()).join();
    }
    if (message.belt5 !== undefined) {
      Belt.encode(message.belt5, writer.uint32(42).fork()).join();
    }
    if (message.belt6 !== undefined) {
      Belt.encode(message.belt6, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SixBelt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSixBelt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.belt1 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.belt2 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.belt3 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.belt4 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.belt5 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.belt6 = Belt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SixBelt>): SixBelt {
    return SixBelt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SixBelt>): SixBelt {
    const message = createBaseSixBelt();
    message.belt1 = (object.belt1 !== undefined && object.belt1 !== null) ? Belt.fromPartial(object.belt1) : undefined;
    message.belt2 = (object.belt2 !== undefined && object.belt2 !== null) ? Belt.fromPartial(object.belt2) : undefined;
    message.belt3 = (object.belt3 !== undefined && object.belt3 !== null) ? Belt.fromPartial(object.belt3) : undefined;
    message.belt4 = (object.belt4 !== undefined && object.belt4 !== null) ? Belt.fromPartial(object.belt4) : undefined;
    message.belt5 = (object.belt5 !== undefined && object.belt5 !== null) ? Belt.fromPartial(object.belt5) : undefined;
    message.belt6 = (object.belt6 !== undefined && object.belt6 !== null) ? Belt.fromPartial(object.belt6) : undefined;
    return message;
  },
};

function createBaseBelt(): Belt {
  return { value: "0" };
}

export const Belt: MessageFns<Belt> = {
  encode(message: Belt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "0") {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Belt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBelt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Belt>): Belt {
    return Belt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Belt>): Belt {
    const message = createBaseBelt();
    message.value = object.value ?? "0";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
