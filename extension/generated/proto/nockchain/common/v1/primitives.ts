// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: nockchain/common/v1/primitives.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "nockchain.common.v1";

export enum ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0,
  ERROR_CODE_INVALID_REQUEST = 1,
  ERROR_CODE_PEEK_FAILED = 2,
  ERROR_CODE_PEEK_RETURNED_NO_DATA = 3,
  ERROR_CODE_POKE_FAILED = 4,
  ERROR_CODE_NACKAPP_ERROR = 5,
  ERROR_CODE_TIMEOUT = 6,
  ERROR_CODE_INTERNAL_ERROR = 7,
  ERROR_CODE_NOT_FOUND = 8,
  ERROR_CODE_PERMISSION_DENIED = 9,
  ERROR_CODE_INVALID_WIRE = 10,
  ERROR_CODE_KERNEL_ERROR = 11,
  UNRECOGNIZED = -1,
}

export function errorCodeFromJSON(object: any): ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_CODE_UNSPECIFIED":
      return ErrorCode.ERROR_CODE_UNSPECIFIED;
    case 1:
    case "ERROR_CODE_INVALID_REQUEST":
      return ErrorCode.ERROR_CODE_INVALID_REQUEST;
    case 2:
    case "ERROR_CODE_PEEK_FAILED":
      return ErrorCode.ERROR_CODE_PEEK_FAILED;
    case 3:
    case "ERROR_CODE_PEEK_RETURNED_NO_DATA":
      return ErrorCode.ERROR_CODE_PEEK_RETURNED_NO_DATA;
    case 4:
    case "ERROR_CODE_POKE_FAILED":
      return ErrorCode.ERROR_CODE_POKE_FAILED;
    case 5:
    case "ERROR_CODE_NACKAPP_ERROR":
      return ErrorCode.ERROR_CODE_NACKAPP_ERROR;
    case 6:
    case "ERROR_CODE_TIMEOUT":
      return ErrorCode.ERROR_CODE_TIMEOUT;
    case 7:
    case "ERROR_CODE_INTERNAL_ERROR":
      return ErrorCode.ERROR_CODE_INTERNAL_ERROR;
    case 8:
    case "ERROR_CODE_NOT_FOUND":
      return ErrorCode.ERROR_CODE_NOT_FOUND;
    case 9:
    case "ERROR_CODE_PERMISSION_DENIED":
      return ErrorCode.ERROR_CODE_PERMISSION_DENIED;
    case 10:
    case "ERROR_CODE_INVALID_WIRE":
      return ErrorCode.ERROR_CODE_INVALID_WIRE;
    case 11:
    case "ERROR_CODE_KERNEL_ERROR":
      return ErrorCode.ERROR_CODE_KERNEL_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCode.UNRECOGNIZED;
  }
}

export function errorCodeToJSON(object: ErrorCode): string {
  switch (object) {
    case ErrorCode.ERROR_CODE_UNSPECIFIED:
      return "ERROR_CODE_UNSPECIFIED";
    case ErrorCode.ERROR_CODE_INVALID_REQUEST:
      return "ERROR_CODE_INVALID_REQUEST";
    case ErrorCode.ERROR_CODE_PEEK_FAILED:
      return "ERROR_CODE_PEEK_FAILED";
    case ErrorCode.ERROR_CODE_PEEK_RETURNED_NO_DATA:
      return "ERROR_CODE_PEEK_RETURNED_NO_DATA";
    case ErrorCode.ERROR_CODE_POKE_FAILED:
      return "ERROR_CODE_POKE_FAILED";
    case ErrorCode.ERROR_CODE_NACKAPP_ERROR:
      return "ERROR_CODE_NACKAPP_ERROR";
    case ErrorCode.ERROR_CODE_TIMEOUT:
      return "ERROR_CODE_TIMEOUT";
    case ErrorCode.ERROR_CODE_INTERNAL_ERROR:
      return "ERROR_CODE_INTERNAL_ERROR";
    case ErrorCode.ERROR_CODE_NOT_FOUND:
      return "ERROR_CODE_NOT_FOUND";
    case ErrorCode.ERROR_CODE_PERMISSION_DENIED:
      return "ERROR_CODE_PERMISSION_DENIED";
    case ErrorCode.ERROR_CODE_INVALID_WIRE:
      return "ERROR_CODE_INVALID_WIRE";
    case ErrorCode.ERROR_CODE_KERNEL_ERROR:
      return "ERROR_CODE_KERNEL_ERROR";
    case ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ErrorStatus {
  code: ErrorCode;
  message: string;
  /** additional error context */
  details?: string | undefined;
}

export interface Acknowledged {
}

export interface Wire {
  /** e.g., "http", "file", "wallet", "grpc" */
  source: string;
  /** wire format version */
  version: number;
  /** operation-specific tags */
  tags: WireTag[];
}

export interface WireTag {
  text?: string | undefined;
  number?: number | undefined;
}

/**
 * Note: prefer using raw numeric fields in messages
 * instead of these wrappers to simplify conversions.
 * These remain defined for potential future use.
 */
export interface NoteVersion {
  value: number;
}

export interface BlockHeight {
  value: number;
}

export interface BlockHeightDelta {
  value: number;
}

export interface Nicks {
  value: number;
}

/**
 * pub chal: [Belt; 8],
 * pub sig: [Belt; 8],
 */
export interface EightBelt {
  belt1: Belt | undefined;
  belt2: Belt | undefined;
  belt3: Belt | undefined;
  belt4: Belt | undefined;
  belt5: Belt | undefined;
  belt6: Belt | undefined;
  belt7: Belt | undefined;
  belt8: Belt | undefined;
}

/**
 * pub struct Hash(pub [Belt; 5]);
 * Use fixed fields to avoid variable-length vectors.
 */
export interface Hash {
  belt1: Belt | undefined;
  belt2: Belt | undefined;
  belt3: Belt | undefined;
  belt4: Belt | undefined;
  belt5: Belt | undefined;
}

export interface Base58Hash {
  hash: string;
}

export interface Base58Pubkey {
  key: string;
}

/** pub struct SchnorrPubkey(pub CheetahPoint); */
export interface SchnorrPubkey {
  value: CheetahPoint | undefined;
}

/**
 * pub struct CheetahPoint {
 *   pub x: F6lt,
 *   pub y: F6lt,
 *   pub inf: bool,
 * }
 */
export interface CheetahPoint {
  x: SixBelt | undefined;
  y: SixBelt | undefined;
  inf: boolean;
}

/** pub struct F6lt(pub [Belt; 6]); */
export interface SixBelt {
  belt1: Belt | undefined;
  belt2: Belt | undefined;
  belt3: Belt | undefined;
  belt4: Belt | undefined;
  belt5: Belt | undefined;
  belt6: Belt | undefined;
}

/** pub struct Belt(pub u64); */
export interface Belt {
  value: number;
}

function createBaseErrorStatus(): ErrorStatus {
  return { code: 0, message: "", details: undefined };
}

export const ErrorStatus: MessageFns<ErrorStatus> = {
  encode(message: ErrorStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== undefined) {
      writer.uint32(26).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorStatus {
    return {
      code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : undefined,
    };
  },

  toJSON(message: ErrorStatus): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = errorCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorStatus>, I>>(base?: I): ErrorStatus {
    return ErrorStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorStatus>, I>>(object: I): ErrorStatus {
    const message = createBaseErrorStatus();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.details = object.details ?? undefined;
    return message;
  },
};

function createBaseAcknowledged(): Acknowledged {
  return {};
}

export const Acknowledged: MessageFns<Acknowledged> = {
  encode(_: Acknowledged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Acknowledged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Acknowledged {
    return {};
  },

  toJSON(_: Acknowledged): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Acknowledged>, I>>(base?: I): Acknowledged {
    return Acknowledged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Acknowledged>, I>>(_: I): Acknowledged {
    const message = createBaseAcknowledged();
    return message;
  },
};

function createBaseWire(): Wire {
  return { source: "", version: 0, tags: [] };
}

export const Wire: MessageFns<Wire> = {
  encode(message: Wire, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.version !== 0) {
      writer.uint32(16).uint64(message.version);
    }
    for (const v of message.tags) {
      WireTag.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wire {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWire();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tags.push(WireTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wire {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => WireTag.fromJSON(e)) : [],
    };
  },

  toJSON(message: Wire): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => WireTag.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wire>, I>>(base?: I): Wire {
    return Wire.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wire>, I>>(object: I): Wire {
    const message = createBaseWire();
    message.source = object.source ?? "";
    message.version = object.version ?? 0;
    message.tags = object.tags?.map((e) => WireTag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWireTag(): WireTag {
  return { text: undefined, number: undefined };
}

export const WireTag: MessageFns<WireTag> = {
  encode(message: WireTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(10).string(message.text);
    }
    if (message.number !== undefined) {
      writer.uint32(16).uint64(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.number = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireTag {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      number: isSet(object.number) ? globalThis.Number(object.number) : undefined,
    };
  },

  toJSON(message: WireTag): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.number !== undefined) {
      obj.number = Math.round(message.number);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireTag>, I>>(base?: I): WireTag {
    return WireTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireTag>, I>>(object: I): WireTag {
    const message = createBaseWireTag();
    message.text = object.text ?? undefined;
    message.number = object.number ?? undefined;
    return message;
  },
};

function createBaseNoteVersion(): NoteVersion {
  return { value: 0 };
}

export const NoteVersion: MessageFns<NoteVersion> = {
  encode(message: NoteVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoteVersion {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: NoteVersion): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteVersion>, I>>(base?: I): NoteVersion {
    return NoteVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteVersion>, I>>(object: I): NoteVersion {
    const message = createBaseNoteVersion();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseBlockHeight(): BlockHeight {
  return { value: 0 };
}

export const BlockHeight: MessageFns<BlockHeight> = {
  encode(message: BlockHeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeight {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: BlockHeight): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeight>, I>>(base?: I): BlockHeight {
    return BlockHeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeight>, I>>(object: I): BlockHeight {
    const message = createBaseBlockHeight();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseBlockHeightDelta(): BlockHeightDelta {
  return { value: 0 };
}

export const BlockHeightDelta: MessageFns<BlockHeightDelta> = {
  encode(message: BlockHeightDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeightDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeightDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeightDelta {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: BlockHeightDelta): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeightDelta>, I>>(base?: I): BlockHeightDelta {
    return BlockHeightDelta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeightDelta>, I>>(object: I): BlockHeightDelta {
    const message = createBaseBlockHeightDelta();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseNicks(): Nicks {
  return { value: 0 };
}

export const Nicks: MessageFns<Nicks> = {
  encode(message: Nicks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Nicks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNicks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Nicks {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: Nicks): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Nicks>, I>>(base?: I): Nicks {
    return Nicks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Nicks>, I>>(object: I): Nicks {
    const message = createBaseNicks();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEightBelt(): EightBelt {
  return {
    belt1: undefined,
    belt2: undefined,
    belt3: undefined,
    belt4: undefined,
    belt5: undefined,
    belt6: undefined,
    belt7: undefined,
    belt8: undefined,
  };
}

export const EightBelt: MessageFns<EightBelt> = {
  encode(message: EightBelt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.belt1 !== undefined) {
      Belt.encode(message.belt1, writer.uint32(10).fork()).join();
    }
    if (message.belt2 !== undefined) {
      Belt.encode(message.belt2, writer.uint32(18).fork()).join();
    }
    if (message.belt3 !== undefined) {
      Belt.encode(message.belt3, writer.uint32(26).fork()).join();
    }
    if (message.belt4 !== undefined) {
      Belt.encode(message.belt4, writer.uint32(34).fork()).join();
    }
    if (message.belt5 !== undefined) {
      Belt.encode(message.belt5, writer.uint32(42).fork()).join();
    }
    if (message.belt6 !== undefined) {
      Belt.encode(message.belt6, writer.uint32(50).fork()).join();
    }
    if (message.belt7 !== undefined) {
      Belt.encode(message.belt7, writer.uint32(58).fork()).join();
    }
    if (message.belt8 !== undefined) {
      Belt.encode(message.belt8, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EightBelt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEightBelt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.belt1 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.belt2 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.belt3 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.belt4 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.belt5 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.belt6 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.belt7 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.belt8 = Belt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EightBelt {
    return {
      belt1: isSet(object.belt1) ? Belt.fromJSON(object.belt1) : undefined,
      belt2: isSet(object.belt2) ? Belt.fromJSON(object.belt2) : undefined,
      belt3: isSet(object.belt3) ? Belt.fromJSON(object.belt3) : undefined,
      belt4: isSet(object.belt4) ? Belt.fromJSON(object.belt4) : undefined,
      belt5: isSet(object.belt5) ? Belt.fromJSON(object.belt5) : undefined,
      belt6: isSet(object.belt6) ? Belt.fromJSON(object.belt6) : undefined,
      belt7: isSet(object.belt7) ? Belt.fromJSON(object.belt7) : undefined,
      belt8: isSet(object.belt8) ? Belt.fromJSON(object.belt8) : undefined,
    };
  },

  toJSON(message: EightBelt): unknown {
    const obj: any = {};
    if (message.belt1 !== undefined) {
      obj.belt1 = Belt.toJSON(message.belt1);
    }
    if (message.belt2 !== undefined) {
      obj.belt2 = Belt.toJSON(message.belt2);
    }
    if (message.belt3 !== undefined) {
      obj.belt3 = Belt.toJSON(message.belt3);
    }
    if (message.belt4 !== undefined) {
      obj.belt4 = Belt.toJSON(message.belt4);
    }
    if (message.belt5 !== undefined) {
      obj.belt5 = Belt.toJSON(message.belt5);
    }
    if (message.belt6 !== undefined) {
      obj.belt6 = Belt.toJSON(message.belt6);
    }
    if (message.belt7 !== undefined) {
      obj.belt7 = Belt.toJSON(message.belt7);
    }
    if (message.belt8 !== undefined) {
      obj.belt8 = Belt.toJSON(message.belt8);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EightBelt>, I>>(base?: I): EightBelt {
    return EightBelt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EightBelt>, I>>(object: I): EightBelt {
    const message = createBaseEightBelt();
    message.belt1 = (object.belt1 !== undefined && object.belt1 !== null) ? Belt.fromPartial(object.belt1) : undefined;
    message.belt2 = (object.belt2 !== undefined && object.belt2 !== null) ? Belt.fromPartial(object.belt2) : undefined;
    message.belt3 = (object.belt3 !== undefined && object.belt3 !== null) ? Belt.fromPartial(object.belt3) : undefined;
    message.belt4 = (object.belt4 !== undefined && object.belt4 !== null) ? Belt.fromPartial(object.belt4) : undefined;
    message.belt5 = (object.belt5 !== undefined && object.belt5 !== null) ? Belt.fromPartial(object.belt5) : undefined;
    message.belt6 = (object.belt6 !== undefined && object.belt6 !== null) ? Belt.fromPartial(object.belt6) : undefined;
    message.belt7 = (object.belt7 !== undefined && object.belt7 !== null) ? Belt.fromPartial(object.belt7) : undefined;
    message.belt8 = (object.belt8 !== undefined && object.belt8 !== null) ? Belt.fromPartial(object.belt8) : undefined;
    return message;
  },
};

function createBaseHash(): Hash {
  return { belt1: undefined, belt2: undefined, belt3: undefined, belt4: undefined, belt5: undefined };
}

export const Hash: MessageFns<Hash> = {
  encode(message: Hash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.belt1 !== undefined) {
      Belt.encode(message.belt1, writer.uint32(10).fork()).join();
    }
    if (message.belt2 !== undefined) {
      Belt.encode(message.belt2, writer.uint32(18).fork()).join();
    }
    if (message.belt3 !== undefined) {
      Belt.encode(message.belt3, writer.uint32(26).fork()).join();
    }
    if (message.belt4 !== undefined) {
      Belt.encode(message.belt4, writer.uint32(34).fork()).join();
    }
    if (message.belt5 !== undefined) {
      Belt.encode(message.belt5, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.belt1 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.belt2 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.belt3 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.belt4 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.belt5 = Belt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hash {
    return {
      belt1: isSet(object.belt1) ? Belt.fromJSON(object.belt1) : undefined,
      belt2: isSet(object.belt2) ? Belt.fromJSON(object.belt2) : undefined,
      belt3: isSet(object.belt3) ? Belt.fromJSON(object.belt3) : undefined,
      belt4: isSet(object.belt4) ? Belt.fromJSON(object.belt4) : undefined,
      belt5: isSet(object.belt5) ? Belt.fromJSON(object.belt5) : undefined,
    };
  },

  toJSON(message: Hash): unknown {
    const obj: any = {};
    if (message.belt1 !== undefined) {
      obj.belt1 = Belt.toJSON(message.belt1);
    }
    if (message.belt2 !== undefined) {
      obj.belt2 = Belt.toJSON(message.belt2);
    }
    if (message.belt3 !== undefined) {
      obj.belt3 = Belt.toJSON(message.belt3);
    }
    if (message.belt4 !== undefined) {
      obj.belt4 = Belt.toJSON(message.belt4);
    }
    if (message.belt5 !== undefined) {
      obj.belt5 = Belt.toJSON(message.belt5);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hash>, I>>(base?: I): Hash {
    return Hash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hash>, I>>(object: I): Hash {
    const message = createBaseHash();
    message.belt1 = (object.belt1 !== undefined && object.belt1 !== null) ? Belt.fromPartial(object.belt1) : undefined;
    message.belt2 = (object.belt2 !== undefined && object.belt2 !== null) ? Belt.fromPartial(object.belt2) : undefined;
    message.belt3 = (object.belt3 !== undefined && object.belt3 !== null) ? Belt.fromPartial(object.belt3) : undefined;
    message.belt4 = (object.belt4 !== undefined && object.belt4 !== null) ? Belt.fromPartial(object.belt4) : undefined;
    message.belt5 = (object.belt5 !== undefined && object.belt5 !== null) ? Belt.fromPartial(object.belt5) : undefined;
    return message;
  },
};

function createBaseBase58Hash(): Base58Hash {
  return { hash: "" };
}

export const Base58Hash: MessageFns<Base58Hash> = {
  encode(message: Base58Hash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Base58Hash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBase58Hash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Base58Hash {
    return { hash: isSet(object.hash) ? globalThis.String(object.hash) : "" };
  },

  toJSON(message: Base58Hash): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Base58Hash>, I>>(base?: I): Base58Hash {
    return Base58Hash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Base58Hash>, I>>(object: I): Base58Hash {
    const message = createBaseBase58Hash();
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseBase58Pubkey(): Base58Pubkey {
  return { key: "" };
}

export const Base58Pubkey: MessageFns<Base58Pubkey> = {
  encode(message: Base58Pubkey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Base58Pubkey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBase58Pubkey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Base58Pubkey {
    return { key: isSet(object.key) ? globalThis.String(object.key) : "" };
  },

  toJSON(message: Base58Pubkey): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Base58Pubkey>, I>>(base?: I): Base58Pubkey {
    return Base58Pubkey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Base58Pubkey>, I>>(object: I): Base58Pubkey {
    const message = createBaseBase58Pubkey();
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseSchnorrPubkey(): SchnorrPubkey {
  return { value: undefined };
}

export const SchnorrPubkey: MessageFns<SchnorrPubkey> = {
  encode(message: SchnorrPubkey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      CheetahPoint.encode(message.value, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchnorrPubkey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchnorrPubkey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = CheetahPoint.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchnorrPubkey {
    return { value: isSet(object.value) ? CheetahPoint.fromJSON(object.value) : undefined };
  },

  toJSON(message: SchnorrPubkey): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = CheetahPoint.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchnorrPubkey>, I>>(base?: I): SchnorrPubkey {
    return SchnorrPubkey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchnorrPubkey>, I>>(object: I): SchnorrPubkey {
    const message = createBaseSchnorrPubkey();
    message.value = (object.value !== undefined && object.value !== null)
      ? CheetahPoint.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCheetahPoint(): CheetahPoint {
  return { x: undefined, y: undefined, inf: false };
}

export const CheetahPoint: MessageFns<CheetahPoint> = {
  encode(message: CheetahPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== undefined) {
      SixBelt.encode(message.x, writer.uint32(10).fork()).join();
    }
    if (message.y !== undefined) {
      SixBelt.encode(message.y, writer.uint32(18).fork()).join();
    }
    if (message.inf !== false) {
      writer.uint32(24).bool(message.inf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheetahPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheetahPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.x = SixBelt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.y = SixBelt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inf = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheetahPoint {
    return {
      x: isSet(object.x) ? SixBelt.fromJSON(object.x) : undefined,
      y: isSet(object.y) ? SixBelt.fromJSON(object.y) : undefined,
      inf: isSet(object.inf) ? globalThis.Boolean(object.inf) : false,
    };
  },

  toJSON(message: CheetahPoint): unknown {
    const obj: any = {};
    if (message.x !== undefined) {
      obj.x = SixBelt.toJSON(message.x);
    }
    if (message.y !== undefined) {
      obj.y = SixBelt.toJSON(message.y);
    }
    if (message.inf !== false) {
      obj.inf = message.inf;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheetahPoint>, I>>(base?: I): CheetahPoint {
    return CheetahPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheetahPoint>, I>>(object: I): CheetahPoint {
    const message = createBaseCheetahPoint();
    message.x = (object.x !== undefined && object.x !== null) ? SixBelt.fromPartial(object.x) : undefined;
    message.y = (object.y !== undefined && object.y !== null) ? SixBelt.fromPartial(object.y) : undefined;
    message.inf = object.inf ?? false;
    return message;
  },
};

function createBaseSixBelt(): SixBelt {
  return { belt1: undefined, belt2: undefined, belt3: undefined, belt4: undefined, belt5: undefined, belt6: undefined };
}

export const SixBelt: MessageFns<SixBelt> = {
  encode(message: SixBelt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.belt1 !== undefined) {
      Belt.encode(message.belt1, writer.uint32(10).fork()).join();
    }
    if (message.belt2 !== undefined) {
      Belt.encode(message.belt2, writer.uint32(18).fork()).join();
    }
    if (message.belt3 !== undefined) {
      Belt.encode(message.belt3, writer.uint32(26).fork()).join();
    }
    if (message.belt4 !== undefined) {
      Belt.encode(message.belt4, writer.uint32(34).fork()).join();
    }
    if (message.belt5 !== undefined) {
      Belt.encode(message.belt5, writer.uint32(42).fork()).join();
    }
    if (message.belt6 !== undefined) {
      Belt.encode(message.belt6, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SixBelt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSixBelt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.belt1 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.belt2 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.belt3 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.belt4 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.belt5 = Belt.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.belt6 = Belt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SixBelt {
    return {
      belt1: isSet(object.belt1) ? Belt.fromJSON(object.belt1) : undefined,
      belt2: isSet(object.belt2) ? Belt.fromJSON(object.belt2) : undefined,
      belt3: isSet(object.belt3) ? Belt.fromJSON(object.belt3) : undefined,
      belt4: isSet(object.belt4) ? Belt.fromJSON(object.belt4) : undefined,
      belt5: isSet(object.belt5) ? Belt.fromJSON(object.belt5) : undefined,
      belt6: isSet(object.belt6) ? Belt.fromJSON(object.belt6) : undefined,
    };
  },

  toJSON(message: SixBelt): unknown {
    const obj: any = {};
    if (message.belt1 !== undefined) {
      obj.belt1 = Belt.toJSON(message.belt1);
    }
    if (message.belt2 !== undefined) {
      obj.belt2 = Belt.toJSON(message.belt2);
    }
    if (message.belt3 !== undefined) {
      obj.belt3 = Belt.toJSON(message.belt3);
    }
    if (message.belt4 !== undefined) {
      obj.belt4 = Belt.toJSON(message.belt4);
    }
    if (message.belt5 !== undefined) {
      obj.belt5 = Belt.toJSON(message.belt5);
    }
    if (message.belt6 !== undefined) {
      obj.belt6 = Belt.toJSON(message.belt6);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SixBelt>, I>>(base?: I): SixBelt {
    return SixBelt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SixBelt>, I>>(object: I): SixBelt {
    const message = createBaseSixBelt();
    message.belt1 = (object.belt1 !== undefined && object.belt1 !== null) ? Belt.fromPartial(object.belt1) : undefined;
    message.belt2 = (object.belt2 !== undefined && object.belt2 !== null) ? Belt.fromPartial(object.belt2) : undefined;
    message.belt3 = (object.belt3 !== undefined && object.belt3 !== null) ? Belt.fromPartial(object.belt3) : undefined;
    message.belt4 = (object.belt4 !== undefined && object.belt4 !== null) ? Belt.fromPartial(object.belt4) : undefined;
    message.belt5 = (object.belt5 !== undefined && object.belt5 !== null) ? Belt.fromPartial(object.belt5) : undefined;
    message.belt6 = (object.belt6 !== undefined && object.belt6 !== null) ? Belt.fromPartial(object.belt6) : undefined;
    return message;
  },
};

function createBaseBelt(): Belt {
  return { value: 0 };
}

export const Belt: MessageFns<Belt> = {
  encode(message: Belt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Belt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBelt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Belt {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: Belt): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Belt>, I>>(base?: I): Belt {
    return Belt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Belt>, I>>(object: I): Belt {
    const message = createBaseBelt();
    message.value = object.value ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
