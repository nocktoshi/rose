// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: nockchain/common/v1/blockchain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageResponse } from "./pagination";
import { BlockHeight, BlockHeightDelta, EightBelt, Hash, Nicks, NoteVersion, SchnorrPubkey } from "./primitives";

export const protobufPackage = "nockchain.common.v1";

export interface WalletBalanceData {
  /**
   * Page of full UTXO entries for the requested wallet. Entries are ordered
   * by (Name.first, Name.last) to support consistent pagination.
   */
  notes: BalanceEntry[];
  /**
   * Snapshot metadata where this page was computed. Clients should include
   * the returned page token to continue paging against the same snapshot.
   */
  height:
    | BlockHeight
    | undefined;
  /** block where balance was computed */
  blockId?:
    | Hash
    | undefined;
  /**
   * Pagination cursor for fetching the next page in a paginated view.
   * When empty, there are no further results for this snapshot.
   */
  page: PageResponse | undefined;
}

export interface BalanceEntry {
  name: Name | undefined;
  note: Note | undefined;
}

/**
 * the string key is the name of the input
 * message RawTransaction { map<Name, Input> inputs = 1; }
 */
export interface RawTransaction {
  namedInputs: NamedInput[];
  timelockRange: TimeLockRangeAbsolute | undefined;
  totalFees: Nicks | undefined;
  id: Hash | undefined;
}

export interface NamedInput {
  name: Name | undefined;
  input: Input | undefined;
}

export interface Input {
  note: Note | undefined;
  spend: Spend | undefined;
}

export interface Spend {
  signature: Signature | undefined;
  seeds: Seed[];
  minerFeeNicks: Nicks | undefined;
}

export interface Seed {
  outputSource?: OutputSource | undefined;
  recipient: Lock | undefined;
  timelockIntent?: TimeLockIntent | undefined;
  gift: Nicks | undefined;
  parentHash: Hash | undefined;
}

export interface OutputSource {
  source?: Source | undefined;
}

export interface Source {
  hash: Hash | undefined;
  coinbase: boolean;
}

export interface TimeLockIntent {
  absolute?: TimeLockRangeAbsolute | undefined;
  relative?: TimeLockRangeRelative | undefined;
  absoluteAndRelative?: TimeLockRangeAbsoluteAndRelative | undefined;
  neither?: TimeLockRangeNeither | undefined;
}

/** Use this when you want to force the output to not have a timelock */
export interface TimeLockRangeNeither {
}

export interface TimeLockRangeAbsoluteAndRelative {
  absolute?: TimeLockRangeAbsolute | undefined;
  relative?: TimeLockRangeRelative | undefined;
}

/** min and max are absolute origin page numbers */
export interface TimeLockRangeAbsolute {
  min?: BlockHeight | undefined;
  max?: BlockHeight | undefined;
}

/** min and max are relative to the note's creation page */
export interface TimeLockRangeRelative {
  min?: BlockHeightDelta | undefined;
  max?: BlockHeightDelta | undefined;
}

export interface Lock {
  /** threshold of keys required to spend the note */
  keysRequired: number;
  /** DEPRECATED: repeated string schnorr_pubkeys_b58 = 2; */
  schnorrPubkeys: SchnorrPubkey[];
}

export interface Name {
  /** First is the hash of whether the note has a timelock and the lock */
  first:
    | Hash
    | undefined;
  /** Last is the hash of the actual timelock and the source */
  last: Hash | undefined;
}

export interface Note {
  /** page-number when added to balance */
  originPage:
    | BlockHeight
    | undefined;
  /** enforced timelock */
  timelock?:
    | TimeLockIntent
    | undefined;
  /** nname (human/name label) */
  name:
    | Name
    | undefined;
  /** spending condition */
  lock:
    | Lock
    | undefined;
  /** provenance commitment */
  source:
    | Source
    | undefined;
  /** coin amount (nicks) */
  assets:
    | Nicks
    | undefined;
  /** note version (currently 0) */
  version: NoteVersion | undefined;
}

export interface Signature {
  entries: SignatureEntry[];
}

export interface SignatureEntry {
  /** serialized pubkey corresponding to the signer */
  schnorrPubkey: SchnorrPubkey | undefined;
  signature: SchnorrSignature | undefined;
}

export interface SchnorrSignature {
  chal: EightBelt | undefined;
  sig: EightBelt | undefined;
}

function createBaseWalletBalanceData(): WalletBalanceData {
  return { notes: [], height: undefined, blockId: undefined, page: undefined };
}

export const WalletBalanceData: MessageFns<WalletBalanceData> = {
  encode(message: WalletBalanceData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notes) {
      BalanceEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.height !== undefined) {
      BlockHeight.encode(message.height, writer.uint32(18).fork()).join();
    }
    if (message.blockId !== undefined) {
      Hash.encode(message.blockId, writer.uint32(26).fork()).join();
    }
    if (message.page !== undefined) {
      PageResponse.encode(message.page, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletBalanceData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletBalanceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notes.push(BalanceEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.height = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockId = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.page = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WalletBalanceData>): WalletBalanceData {
    return WalletBalanceData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WalletBalanceData>): WalletBalanceData {
    const message = createBaseWalletBalanceData();
    message.notes = object.notes?.map((e) => BalanceEntry.fromPartial(e)) || [];
    message.height = (object.height !== undefined && object.height !== null)
      ? BlockHeight.fromPartial(object.height)
      : undefined;
    message.blockId = (object.blockId !== undefined && object.blockId !== null)
      ? Hash.fromPartial(object.blockId)
      : undefined;
    message.page = (object.page !== undefined && object.page !== null)
      ? PageResponse.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBaseBalanceEntry(): BalanceEntry {
  return { name: undefined, note: undefined };
}

export const BalanceEntry: MessageFns<BalanceEntry> = {
  encode(message: BalanceEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BalanceEntry>): BalanceEntry {
    return BalanceEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalanceEntry>): BalanceEntry {
    const message = createBaseBalanceEntry();
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    return message;
  },
};

function createBaseRawTransaction(): RawTransaction {
  return { namedInputs: [], timelockRange: undefined, totalFees: undefined, id: undefined };
}

export const RawTransaction: MessageFns<RawTransaction> = {
  encode(message: RawTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.namedInputs) {
      NamedInput.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.timelockRange !== undefined) {
      TimeLockRangeAbsolute.encode(message.timelockRange, writer.uint32(18).fork()).join();
    }
    if (message.totalFees !== undefined) {
      Nicks.encode(message.totalFees, writer.uint32(26).fork()).join();
    }
    if (message.id !== undefined) {
      Hash.encode(message.id, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedInputs.push(NamedInput.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timelockRange = TimeLockRangeAbsolute.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalFees = Nicks.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = Hash.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RawTransaction>): RawTransaction {
    return RawTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawTransaction>): RawTransaction {
    const message = createBaseRawTransaction();
    message.namedInputs = object.namedInputs?.map((e) => NamedInput.fromPartial(e)) || [];
    message.timelockRange = (object.timelockRange !== undefined && object.timelockRange !== null)
      ? TimeLockRangeAbsolute.fromPartial(object.timelockRange)
      : undefined;
    message.totalFees = (object.totalFees !== undefined && object.totalFees !== null)
      ? Nicks.fromPartial(object.totalFees)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? Hash.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseNamedInput(): NamedInput {
  return { name: undefined, input: undefined };
}

export const NamedInput: MessageFns<NamedInput> = {
  encode(message: NamedInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NamedInput>): NamedInput {
    return NamedInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NamedInput>): NamedInput {
    const message = createBaseNamedInput();
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    return message;
  },
};

function createBaseInput(): Input {
  return { note: undefined, spend: undefined };
}

export const Input: MessageFns<Input> = {
  encode(message: Input, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).join();
    }
    if (message.spend !== undefined) {
      Spend.encode(message.spend, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Input {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.spend = Spend.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Input>): Input {
    return Input.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Input>): Input {
    const message = createBaseInput();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.spend = (object.spend !== undefined && object.spend !== null) ? Spend.fromPartial(object.spend) : undefined;
    return message;
  },
};

function createBaseSpend(): Spend {
  return { signature: undefined, seeds: [], minerFeeNicks: undefined };
}

export const Spend: MessageFns<Spend> = {
  encode(message: Spend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(10).fork()).join();
    }
    for (const v of message.seeds) {
      Seed.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.minerFeeNicks !== undefined) {
      Nicks.encode(message.minerFeeNicks, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seeds.push(Seed.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minerFeeNicks = Nicks.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Spend>): Spend {
    return Spend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Spend>): Spend {
    const message = createBaseSpend();
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    message.seeds = object.seeds?.map((e) => Seed.fromPartial(e)) || [];
    message.minerFeeNicks = (object.minerFeeNicks !== undefined && object.minerFeeNicks !== null)
      ? Nicks.fromPartial(object.minerFeeNicks)
      : undefined;
    return message;
  },
};

function createBaseSeed(): Seed {
  return {
    outputSource: undefined,
    recipient: undefined,
    timelockIntent: undefined,
    gift: undefined,
    parentHash: undefined,
  };
}

export const Seed: MessageFns<Seed> = {
  encode(message: Seed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputSource !== undefined) {
      OutputSource.encode(message.outputSource, writer.uint32(10).fork()).join();
    }
    if (message.recipient !== undefined) {
      Lock.encode(message.recipient, writer.uint32(18).fork()).join();
    }
    if (message.timelockIntent !== undefined) {
      TimeLockIntent.encode(message.timelockIntent, writer.uint32(26).fork()).join();
    }
    if (message.gift !== undefined) {
      Nicks.encode(message.gift, writer.uint32(34).fork()).join();
    }
    if (message.parentHash !== undefined) {
      Hash.encode(message.parentHash, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Seed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputSource = OutputSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipient = Lock.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timelockIntent = TimeLockIntent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gift = Nicks.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parentHash = Hash.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Seed>): Seed {
    return Seed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Seed>): Seed {
    const message = createBaseSeed();
    message.outputSource = (object.outputSource !== undefined && object.outputSource !== null)
      ? OutputSource.fromPartial(object.outputSource)
      : undefined;
    message.recipient = (object.recipient !== undefined && object.recipient !== null)
      ? Lock.fromPartial(object.recipient)
      : undefined;
    message.timelockIntent = (object.timelockIntent !== undefined && object.timelockIntent !== null)
      ? TimeLockIntent.fromPartial(object.timelockIntent)
      : undefined;
    message.gift = (object.gift !== undefined && object.gift !== null) ? Nicks.fromPartial(object.gift) : undefined;
    message.parentHash = (object.parentHash !== undefined && object.parentHash !== null)
      ? Hash.fromPartial(object.parentHash)
      : undefined;
    return message;
  },
};

function createBaseOutputSource(): OutputSource {
  return { source: undefined };
}

export const OutputSource: MessageFns<OutputSource> = {
  encode(message: OutputSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OutputSource>): OutputSource {
    return OutputSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutputSource>): OutputSource {
    const message = createBaseOutputSource();
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    return message;
  },
};

function createBaseSource(): Source {
  return { hash: undefined, coinbase: false };
}

export const Source: MessageFns<Source> = {
  encode(message: Source, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== undefined) {
      Hash.encode(message.hash, writer.uint32(10).fork()).join();
    }
    if (message.coinbase !== false) {
      writer.uint32(16).bool(message.coinbase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Source {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.coinbase = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Source>): Source {
    return Source.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Source>): Source {
    const message = createBaseSource();
    message.hash = (object.hash !== undefined && object.hash !== null) ? Hash.fromPartial(object.hash) : undefined;
    message.coinbase = object.coinbase ?? false;
    return message;
  },
};

function createBaseTimeLockIntent(): TimeLockIntent {
  return { absolute: undefined, relative: undefined, absoluteAndRelative: undefined, neither: undefined };
}

export const TimeLockIntent: MessageFns<TimeLockIntent> = {
  encode(message: TimeLockIntent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.absolute !== undefined) {
      TimeLockRangeAbsolute.encode(message.absolute, writer.uint32(10).fork()).join();
    }
    if (message.relative !== undefined) {
      TimeLockRangeRelative.encode(message.relative, writer.uint32(18).fork()).join();
    }
    if (message.absoluteAndRelative !== undefined) {
      TimeLockRangeAbsoluteAndRelative.encode(message.absoluteAndRelative, writer.uint32(26).fork()).join();
    }
    if (message.neither !== undefined) {
      TimeLockRangeNeither.encode(message.neither, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockIntent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.absolute = TimeLockRangeAbsolute.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.relative = TimeLockRangeRelative.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.absoluteAndRelative = TimeLockRangeAbsoluteAndRelative.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.neither = TimeLockRangeNeither.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TimeLockIntent>): TimeLockIntent {
    return TimeLockIntent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeLockIntent>): TimeLockIntent {
    const message = createBaseTimeLockIntent();
    message.absolute = (object.absolute !== undefined && object.absolute !== null)
      ? TimeLockRangeAbsolute.fromPartial(object.absolute)
      : undefined;
    message.relative = (object.relative !== undefined && object.relative !== null)
      ? TimeLockRangeRelative.fromPartial(object.relative)
      : undefined;
    message.absoluteAndRelative = (object.absoluteAndRelative !== undefined && object.absoluteAndRelative !== null)
      ? TimeLockRangeAbsoluteAndRelative.fromPartial(object.absoluteAndRelative)
      : undefined;
    message.neither = (object.neither !== undefined && object.neither !== null)
      ? TimeLockRangeNeither.fromPartial(object.neither)
      : undefined;
    return message;
  },
};

function createBaseTimeLockRangeNeither(): TimeLockRangeNeither {
  return {};
}

export const TimeLockRangeNeither: MessageFns<TimeLockRangeNeither> = {
  encode(_: TimeLockRangeNeither, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockRangeNeither {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockRangeNeither();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TimeLockRangeNeither>): TimeLockRangeNeither {
    return TimeLockRangeNeither.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TimeLockRangeNeither>): TimeLockRangeNeither {
    const message = createBaseTimeLockRangeNeither();
    return message;
  },
};

function createBaseTimeLockRangeAbsoluteAndRelative(): TimeLockRangeAbsoluteAndRelative {
  return { absolute: undefined, relative: undefined };
}

export const TimeLockRangeAbsoluteAndRelative: MessageFns<TimeLockRangeAbsoluteAndRelative> = {
  encode(message: TimeLockRangeAbsoluteAndRelative, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.absolute !== undefined) {
      TimeLockRangeAbsolute.encode(message.absolute, writer.uint32(10).fork()).join();
    }
    if (message.relative !== undefined) {
      TimeLockRangeRelative.encode(message.relative, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockRangeAbsoluteAndRelative {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockRangeAbsoluteAndRelative();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.absolute = TimeLockRangeAbsolute.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.relative = TimeLockRangeRelative.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TimeLockRangeAbsoluteAndRelative>): TimeLockRangeAbsoluteAndRelative {
    return TimeLockRangeAbsoluteAndRelative.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeLockRangeAbsoluteAndRelative>): TimeLockRangeAbsoluteAndRelative {
    const message = createBaseTimeLockRangeAbsoluteAndRelative();
    message.absolute = (object.absolute !== undefined && object.absolute !== null)
      ? TimeLockRangeAbsolute.fromPartial(object.absolute)
      : undefined;
    message.relative = (object.relative !== undefined && object.relative !== null)
      ? TimeLockRangeRelative.fromPartial(object.relative)
      : undefined;
    return message;
  },
};

function createBaseTimeLockRangeAbsolute(): TimeLockRangeAbsolute {
  return { min: undefined, max: undefined };
}

export const TimeLockRangeAbsolute: MessageFns<TimeLockRangeAbsolute> = {
  encode(message: TimeLockRangeAbsolute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      BlockHeight.encode(message.min, writer.uint32(10).fork()).join();
    }
    if (message.max !== undefined) {
      BlockHeight.encode(message.max, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockRangeAbsolute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockRangeAbsolute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.min = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TimeLockRangeAbsolute>): TimeLockRangeAbsolute {
    return TimeLockRangeAbsolute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeLockRangeAbsolute>): TimeLockRangeAbsolute {
    const message = createBaseTimeLockRangeAbsolute();
    message.min = (object.min !== undefined && object.min !== null) ? BlockHeight.fromPartial(object.min) : undefined;
    message.max = (object.max !== undefined && object.max !== null) ? BlockHeight.fromPartial(object.max) : undefined;
    return message;
  },
};

function createBaseTimeLockRangeRelative(): TimeLockRangeRelative {
  return { min: undefined, max: undefined };
}

export const TimeLockRangeRelative: MessageFns<TimeLockRangeRelative> = {
  encode(message: TimeLockRangeRelative, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      BlockHeightDelta.encode(message.min, writer.uint32(10).fork()).join();
    }
    if (message.max !== undefined) {
      BlockHeightDelta.encode(message.max, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockRangeRelative {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockRangeRelative();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.min = BlockHeightDelta.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max = BlockHeightDelta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TimeLockRangeRelative>): TimeLockRangeRelative {
    return TimeLockRangeRelative.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeLockRangeRelative>): TimeLockRangeRelative {
    const message = createBaseTimeLockRangeRelative();
    message.min = (object.min !== undefined && object.min !== null)
      ? BlockHeightDelta.fromPartial(object.min)
      : undefined;
    message.max = (object.max !== undefined && object.max !== null)
      ? BlockHeightDelta.fromPartial(object.max)
      : undefined;
    return message;
  },
};

function createBaseLock(): Lock {
  return { keysRequired: 0, schnorrPubkeys: [] };
}

export const Lock: MessageFns<Lock> = {
  encode(message: Lock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keysRequired !== 0) {
      writer.uint32(8).uint32(message.keysRequired);
    }
    for (const v of message.schnorrPubkeys) {
      SchnorrPubkey.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keysRequired = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schnorrPubkeys.push(SchnorrPubkey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Lock>): Lock {
    return Lock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Lock>): Lock {
    const message = createBaseLock();
    message.keysRequired = object.keysRequired ?? 0;
    message.schnorrPubkeys = object.schnorrPubkeys?.map((e) => SchnorrPubkey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseName(): Name {
  return { first: undefined, last: undefined };
}

export const Name: MessageFns<Name> = {
  encode(message: Name, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.first !== undefined) {
      Hash.encode(message.first, writer.uint32(10).fork()).join();
    }
    if (message.last !== undefined) {
      Hash.encode(message.last, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Name {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.first = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last = Hash.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Name>): Name {
    return Name.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Name>): Name {
    const message = createBaseName();
    message.first = (object.first !== undefined && object.first !== null) ? Hash.fromPartial(object.first) : undefined;
    message.last = (object.last !== undefined && object.last !== null) ? Hash.fromPartial(object.last) : undefined;
    return message;
  },
};

function createBaseNote(): Note {
  return {
    originPage: undefined,
    timelock: undefined,
    name: undefined,
    lock: undefined,
    source: undefined,
    assets: undefined,
    version: undefined,
  };
}

export const Note: MessageFns<Note> = {
  encode(message: Note, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originPage !== undefined) {
      BlockHeight.encode(message.originPage, writer.uint32(10).fork()).join();
    }
    if (message.timelock !== undefined) {
      TimeLockIntent.encode(message.timelock, writer.uint32(18).fork()).join();
    }
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(26).fork()).join();
    }
    if (message.lock !== undefined) {
      Lock.encode(message.lock, writer.uint32(34).fork()).join();
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(42).fork()).join();
    }
    if (message.assets !== undefined) {
      Nicks.encode(message.assets, writer.uint32(50).fork()).join();
    }
    if (message.version !== undefined) {
      NoteVersion.encode(message.version, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Note {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.originPage = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timelock = TimeLockIntent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lock = Lock.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assets = Nicks.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.version = NoteVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Note>): Note {
    return Note.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Note>): Note {
    const message = createBaseNote();
    message.originPage = (object.originPage !== undefined && object.originPage !== null)
      ? BlockHeight.fromPartial(object.originPage)
      : undefined;
    message.timelock = (object.timelock !== undefined && object.timelock !== null)
      ? TimeLockIntent.fromPartial(object.timelock)
      : undefined;
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.lock = (object.lock !== undefined && object.lock !== null) ? Lock.fromPartial(object.lock) : undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.assets = (object.assets !== undefined && object.assets !== null)
      ? Nicks.fromPartial(object.assets)
      : undefined;
    message.version = (object.version !== undefined && object.version !== null)
      ? NoteVersion.fromPartial(object.version)
      : undefined;
    return message;
  },
};

function createBaseSignature(): Signature {
  return { entries: [] };
}

export const Signature: MessageFns<Signature> = {
  encode(message: Signature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      SignatureEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(SignatureEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Signature>): Signature {
    return Signature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Signature>): Signature {
    const message = createBaseSignature();
    message.entries = object.entries?.map((e) => SignatureEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSignatureEntry(): SignatureEntry {
  return { schnorrPubkey: undefined, signature: undefined };
}

export const SignatureEntry: MessageFns<SignatureEntry> = {
  encode(message: SignatureEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schnorrPubkey !== undefined) {
      SchnorrPubkey.encode(message.schnorrPubkey, writer.uint32(10).fork()).join();
    }
    if (message.signature !== undefined) {
      SchnorrSignature.encode(message.signature, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schnorrPubkey = SchnorrPubkey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = SchnorrSignature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SignatureEntry>): SignatureEntry {
    return SignatureEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignatureEntry>): SignatureEntry {
    const message = createBaseSignatureEntry();
    message.schnorrPubkey = (object.schnorrPubkey !== undefined && object.schnorrPubkey !== null)
      ? SchnorrPubkey.fromPartial(object.schnorrPubkey)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? SchnorrSignature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseSchnorrSignature(): SchnorrSignature {
  return { chal: undefined, sig: undefined };
}

export const SchnorrSignature: MessageFns<SchnorrSignature> = {
  encode(message: SchnorrSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chal !== undefined) {
      EightBelt.encode(message.chal, writer.uint32(10).fork()).join();
    }
    if (message.sig !== undefined) {
      EightBelt.encode(message.sig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchnorrSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchnorrSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chal = EightBelt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = EightBelt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SchnorrSignature>): SchnorrSignature {
    return SchnorrSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchnorrSignature>): SchnorrSignature {
    const message = createBaseSchnorrSignature();
    message.chal = (object.chal !== undefined && object.chal !== null) ? EightBelt.fromPartial(object.chal) : undefined;
    message.sig = (object.sig !== undefined && object.sig !== null) ? EightBelt.fromPartial(object.sig) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
