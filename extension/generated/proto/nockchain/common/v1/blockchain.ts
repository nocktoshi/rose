// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: nockchain/common/v1/blockchain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageResponse } from "./pagination";
import { BlockHeight, BlockHeightDelta, EightBelt, Hash, Nicks, NoteVersion, SchnorrPubkey } from "./primitives";

export const protobufPackage = "nockchain.common.v1";

export interface WalletBalanceData {
  /**
   * Page of full UTXO entries for the requested wallet. Entries are ordered
   * by (Name.first, Name.last) to support consistent pagination.
   */
  notes: BalanceEntry[];
  /**
   * Snapshot metadata where this page was computed. Clients should include
   * the returned page token to continue paging against the same snapshot.
   */
  height:
    | BlockHeight
    | undefined;
  /** block where balance was computed */
  blockId?:
    | Hash
    | undefined;
  /**
   * Pagination cursor for fetching the next page in a paginated view.
   * When empty, there are no further results for this snapshot.
   */
  page: PageResponse | undefined;
}

export interface BalanceEntry {
  name: Name | undefined;
  note: Note | undefined;
}

/**
 * the string key is the name of the input
 * message RawTransaction { map<Name, Input> inputs = 1; }
 */
export interface RawTransaction {
  namedInputs: NamedInput[];
  timelockRange: TimeLockRangeAbsolute | undefined;
  totalFees: Nicks | undefined;
  id: Hash | undefined;
}

export interface NamedInput {
  name: Name | undefined;
  input: Input | undefined;
}

export interface Input {
  note: Note | undefined;
  spend: Spend | undefined;
}

export interface Spend {
  signature: Signature | undefined;
  seeds: Seed[];
  minerFeeNicks: Nicks | undefined;
}

export interface Seed {
  outputSource?: OutputSource | undefined;
  recipient: Lock | undefined;
  timelockIntent?: TimeLockIntent | undefined;
  gift: Nicks | undefined;
  parentHash: Hash | undefined;
}

export interface OutputSource {
  source?: Source | undefined;
}

export interface Source {
  hash: Hash | undefined;
  coinbase: boolean;
}

export interface TimeLockIntent {
  absolute?: TimeLockRangeAbsolute | undefined;
  relative?: TimeLockRangeRelative | undefined;
  absoluteAndRelative?: TimeLockRangeAbsoluteAndRelative | undefined;
  neither?: TimeLockRangeNeither | undefined;
}

/** Use this when you want to force the output to not have a timelock */
export interface TimeLockRangeNeither {
}

export interface TimeLockRangeAbsoluteAndRelative {
  absolute?: TimeLockRangeAbsolute | undefined;
  relative?: TimeLockRangeRelative | undefined;
}

/** min and max are absolute origin page numbers */
export interface TimeLockRangeAbsolute {
  min?: BlockHeight | undefined;
  max?: BlockHeight | undefined;
}

/** min and max are relative to the note's creation page */
export interface TimeLockRangeRelative {
  min?: BlockHeightDelta | undefined;
  max?: BlockHeightDelta | undefined;
}

export interface Lock {
  /** threshold of keys required to spend the note */
  keysRequired: number;
  /** DEPRECATED: repeated string schnorr_pubkeys_b58 = 2; */
  schnorrPubkeys: SchnorrPubkey[];
}

export interface Name {
  /** First is the hash of whether the note has a timelock and the lock */
  first:
    | Hash
    | undefined;
  /** Last is the hash of the actual timelock and the source */
  last: Hash | undefined;
}

export interface Note {
  /** page-number when added to balance */
  originPage:
    | BlockHeight
    | undefined;
  /** enforced timelock */
  timelock?:
    | TimeLockIntent
    | undefined;
  /** nname (human/name label) */
  name:
    | Name
    | undefined;
  /** spending condition */
  lock:
    | Lock
    | undefined;
  /** provenance commitment */
  source:
    | Source
    | undefined;
  /** coin amount (nicks) */
  assets:
    | Nicks
    | undefined;
  /** note version (currently 0) */
  version: NoteVersion | undefined;
}

export interface Signature {
  entries: SignatureEntry[];
}

export interface SignatureEntry {
  /** serialized pubkey corresponding to the signer */
  schnorrPubkey: SchnorrPubkey | undefined;
  signature: SchnorrSignature | undefined;
}

export interface SchnorrSignature {
  chal: EightBelt | undefined;
  sig: EightBelt | undefined;
}

function createBaseWalletBalanceData(): WalletBalanceData {
  return { notes: [], height: undefined, blockId: undefined, page: undefined };
}

export const WalletBalanceData: MessageFns<WalletBalanceData> = {
  encode(message: WalletBalanceData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notes) {
      BalanceEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.height !== undefined) {
      BlockHeight.encode(message.height, writer.uint32(18).fork()).join();
    }
    if (message.blockId !== undefined) {
      Hash.encode(message.blockId, writer.uint32(26).fork()).join();
    }
    if (message.page !== undefined) {
      PageResponse.encode(message.page, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletBalanceData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletBalanceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notes.push(BalanceEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.height = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockId = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.page = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletBalanceData {
    return {
      notes: globalThis.Array.isArray(object?.notes) ? object.notes.map((e: any) => BalanceEntry.fromJSON(e)) : [],
      height: isSet(object.height) ? BlockHeight.fromJSON(object.height) : undefined,
      blockId: isSet(object.blockId) ? Hash.fromJSON(object.blockId) : undefined,
      page: isSet(object.page) ? PageResponse.fromJSON(object.page) : undefined,
    };
  },

  toJSON(message: WalletBalanceData): unknown {
    const obj: any = {};
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => BalanceEntry.toJSON(e));
    }
    if (message.height !== undefined) {
      obj.height = BlockHeight.toJSON(message.height);
    }
    if (message.blockId !== undefined) {
      obj.blockId = Hash.toJSON(message.blockId);
    }
    if (message.page !== undefined) {
      obj.page = PageResponse.toJSON(message.page);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletBalanceData>, I>>(base?: I): WalletBalanceData {
    return WalletBalanceData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletBalanceData>, I>>(object: I): WalletBalanceData {
    const message = createBaseWalletBalanceData();
    message.notes = object.notes?.map((e) => BalanceEntry.fromPartial(e)) || [];
    message.height = (object.height !== undefined && object.height !== null)
      ? BlockHeight.fromPartial(object.height)
      : undefined;
    message.blockId = (object.blockId !== undefined && object.blockId !== null)
      ? Hash.fromPartial(object.blockId)
      : undefined;
    message.page = (object.page !== undefined && object.page !== null)
      ? PageResponse.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBaseBalanceEntry(): BalanceEntry {
  return { name: undefined, note: undefined };
}

export const BalanceEntry: MessageFns<BalanceEntry> = {
  encode(message: BalanceEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceEntry {
    return {
      name: isSet(object.name) ? Name.fromJSON(object.name) : undefined,
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
    };
  },

  toJSON(message: BalanceEntry): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = Name.toJSON(message.name);
    }
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BalanceEntry>, I>>(base?: I): BalanceEntry {
    return BalanceEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BalanceEntry>, I>>(object: I): BalanceEntry {
    const message = createBaseBalanceEntry();
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    return message;
  },
};

function createBaseRawTransaction(): RawTransaction {
  return { namedInputs: [], timelockRange: undefined, totalFees: undefined, id: undefined };
}

export const RawTransaction: MessageFns<RawTransaction> = {
  encode(message: RawTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.namedInputs) {
      NamedInput.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.timelockRange !== undefined) {
      TimeLockRangeAbsolute.encode(message.timelockRange, writer.uint32(18).fork()).join();
    }
    if (message.totalFees !== undefined) {
      Nicks.encode(message.totalFees, writer.uint32(26).fork()).join();
    }
    if (message.id !== undefined) {
      Hash.encode(message.id, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namedInputs.push(NamedInput.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timelockRange = TimeLockRangeAbsolute.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalFees = Nicks.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = Hash.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawTransaction {
    return {
      namedInputs: globalThis.Array.isArray(object?.namedInputs)
        ? object.namedInputs.map((e: any) => NamedInput.fromJSON(e))
        : [],
      timelockRange: isSet(object.timelockRange) ? TimeLockRangeAbsolute.fromJSON(object.timelockRange) : undefined,
      totalFees: isSet(object.totalFees) ? Nicks.fromJSON(object.totalFees) : undefined,
      id: isSet(object.id) ? Hash.fromJSON(object.id) : undefined,
    };
  },

  toJSON(message: RawTransaction): unknown {
    const obj: any = {};
    if (message.namedInputs?.length) {
      obj.namedInputs = message.namedInputs.map((e) => NamedInput.toJSON(e));
    }
    if (message.timelockRange !== undefined) {
      obj.timelockRange = TimeLockRangeAbsolute.toJSON(message.timelockRange);
    }
    if (message.totalFees !== undefined) {
      obj.totalFees = Nicks.toJSON(message.totalFees);
    }
    if (message.id !== undefined) {
      obj.id = Hash.toJSON(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RawTransaction>, I>>(base?: I): RawTransaction {
    return RawTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RawTransaction>, I>>(object: I): RawTransaction {
    const message = createBaseRawTransaction();
    message.namedInputs = object.namedInputs?.map((e) => NamedInput.fromPartial(e)) || [];
    message.timelockRange = (object.timelockRange !== undefined && object.timelockRange !== null)
      ? TimeLockRangeAbsolute.fromPartial(object.timelockRange)
      : undefined;
    message.totalFees = (object.totalFees !== undefined && object.totalFees !== null)
      ? Nicks.fromPartial(object.totalFees)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? Hash.fromPartial(object.id) : undefined;
    return message;
  },
};

function createBaseNamedInput(): NamedInput {
  return { name: undefined, input: undefined };
}

export const NamedInput: MessageFns<NamedInput> = {
  encode(message: NamedInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedInput {
    return {
      name: isSet(object.name) ? Name.fromJSON(object.name) : undefined,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
    };
  },

  toJSON(message: NamedInput): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = Name.toJSON(message.name);
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedInput>, I>>(base?: I): NamedInput {
    return NamedInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedInput>, I>>(object: I): NamedInput {
    const message = createBaseNamedInput();
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    return message;
  },
};

function createBaseInput(): Input {
  return { note: undefined, spend: undefined };
}

export const Input: MessageFns<Input> = {
  encode(message: Input, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).join();
    }
    if (message.spend !== undefined) {
      Spend.encode(message.spend, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Input {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.spend = Spend.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Input {
    return {
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      spend: isSet(object.spend) ? Spend.fromJSON(object.spend) : undefined,
    };
  },

  toJSON(message: Input): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.spend !== undefined) {
      obj.spend = Spend.toJSON(message.spend);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Input>, I>>(base?: I): Input {
    return Input.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Input>, I>>(object: I): Input {
    const message = createBaseInput();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.spend = (object.spend !== undefined && object.spend !== null) ? Spend.fromPartial(object.spend) : undefined;
    return message;
  },
};

function createBaseSpend(): Spend {
  return { signature: undefined, seeds: [], minerFeeNicks: undefined };
}

export const Spend: MessageFns<Spend> = {
  encode(message: Spend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(10).fork()).join();
    }
    for (const v of message.seeds) {
      Seed.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.minerFeeNicks !== undefined) {
      Nicks.encode(message.minerFeeNicks, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seeds.push(Seed.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minerFeeNicks = Nicks.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spend {
    return {
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
      seeds: globalThis.Array.isArray(object?.seeds) ? object.seeds.map((e: any) => Seed.fromJSON(e)) : [],
      minerFeeNicks: isSet(object.minerFeeNicks) ? Nicks.fromJSON(object.minerFeeNicks) : undefined,
    };
  },

  toJSON(message: Spend): unknown {
    const obj: any = {};
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    if (message.seeds?.length) {
      obj.seeds = message.seeds.map((e) => Seed.toJSON(e));
    }
    if (message.minerFeeNicks !== undefined) {
      obj.minerFeeNicks = Nicks.toJSON(message.minerFeeNicks);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spend>, I>>(base?: I): Spend {
    return Spend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spend>, I>>(object: I): Spend {
    const message = createBaseSpend();
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    message.seeds = object.seeds?.map((e) => Seed.fromPartial(e)) || [];
    message.minerFeeNicks = (object.minerFeeNicks !== undefined && object.minerFeeNicks !== null)
      ? Nicks.fromPartial(object.minerFeeNicks)
      : undefined;
    return message;
  },
};

function createBaseSeed(): Seed {
  return {
    outputSource: undefined,
    recipient: undefined,
    timelockIntent: undefined,
    gift: undefined,
    parentHash: undefined,
  };
}

export const Seed: MessageFns<Seed> = {
  encode(message: Seed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputSource !== undefined) {
      OutputSource.encode(message.outputSource, writer.uint32(10).fork()).join();
    }
    if (message.recipient !== undefined) {
      Lock.encode(message.recipient, writer.uint32(18).fork()).join();
    }
    if (message.timelockIntent !== undefined) {
      TimeLockIntent.encode(message.timelockIntent, writer.uint32(26).fork()).join();
    }
    if (message.gift !== undefined) {
      Nicks.encode(message.gift, writer.uint32(34).fork()).join();
    }
    if (message.parentHash !== undefined) {
      Hash.encode(message.parentHash, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Seed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputSource = OutputSource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipient = Lock.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timelockIntent = TimeLockIntent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gift = Nicks.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parentHash = Hash.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Seed {
    return {
      outputSource: isSet(object.outputSource) ? OutputSource.fromJSON(object.outputSource) : undefined,
      recipient: isSet(object.recipient) ? Lock.fromJSON(object.recipient) : undefined,
      timelockIntent: isSet(object.timelockIntent) ? TimeLockIntent.fromJSON(object.timelockIntent) : undefined,
      gift: isSet(object.gift) ? Nicks.fromJSON(object.gift) : undefined,
      parentHash: isSet(object.parentHash) ? Hash.fromJSON(object.parentHash) : undefined,
    };
  },

  toJSON(message: Seed): unknown {
    const obj: any = {};
    if (message.outputSource !== undefined) {
      obj.outputSource = OutputSource.toJSON(message.outputSource);
    }
    if (message.recipient !== undefined) {
      obj.recipient = Lock.toJSON(message.recipient);
    }
    if (message.timelockIntent !== undefined) {
      obj.timelockIntent = TimeLockIntent.toJSON(message.timelockIntent);
    }
    if (message.gift !== undefined) {
      obj.gift = Nicks.toJSON(message.gift);
    }
    if (message.parentHash !== undefined) {
      obj.parentHash = Hash.toJSON(message.parentHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Seed>, I>>(base?: I): Seed {
    return Seed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Seed>, I>>(object: I): Seed {
    const message = createBaseSeed();
    message.outputSource = (object.outputSource !== undefined && object.outputSource !== null)
      ? OutputSource.fromPartial(object.outputSource)
      : undefined;
    message.recipient = (object.recipient !== undefined && object.recipient !== null)
      ? Lock.fromPartial(object.recipient)
      : undefined;
    message.timelockIntent = (object.timelockIntent !== undefined && object.timelockIntent !== null)
      ? TimeLockIntent.fromPartial(object.timelockIntent)
      : undefined;
    message.gift = (object.gift !== undefined && object.gift !== null) ? Nicks.fromPartial(object.gift) : undefined;
    message.parentHash = (object.parentHash !== undefined && object.parentHash !== null)
      ? Hash.fromPartial(object.parentHash)
      : undefined;
    return message;
  },
};

function createBaseOutputSource(): OutputSource {
  return { source: undefined };
}

export const OutputSource: MessageFns<OutputSource> = {
  encode(message: OutputSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputSource {
    return { source: isSet(object.source) ? Source.fromJSON(object.source) : undefined };
  },

  toJSON(message: OutputSource): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputSource>, I>>(base?: I): OutputSource {
    return OutputSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputSource>, I>>(object: I): OutputSource {
    const message = createBaseOutputSource();
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    return message;
  },
};

function createBaseSource(): Source {
  return { hash: undefined, coinbase: false };
}

export const Source: MessageFns<Source> = {
  encode(message: Source, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== undefined) {
      Hash.encode(message.hash, writer.uint32(10).fork()).join();
    }
    if (message.coinbase !== false) {
      writer.uint32(16).bool(message.coinbase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Source {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.coinbase = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source {
    return {
      hash: isSet(object.hash) ? Hash.fromJSON(object.hash) : undefined,
      coinbase: isSet(object.coinbase) ? globalThis.Boolean(object.coinbase) : false,
    };
  },

  toJSON(message: Source): unknown {
    const obj: any = {};
    if (message.hash !== undefined) {
      obj.hash = Hash.toJSON(message.hash);
    }
    if (message.coinbase !== false) {
      obj.coinbase = message.coinbase;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source>, I>>(base?: I): Source {
    return Source.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source>, I>>(object: I): Source {
    const message = createBaseSource();
    message.hash = (object.hash !== undefined && object.hash !== null) ? Hash.fromPartial(object.hash) : undefined;
    message.coinbase = object.coinbase ?? false;
    return message;
  },
};

function createBaseTimeLockIntent(): TimeLockIntent {
  return { absolute: undefined, relative: undefined, absoluteAndRelative: undefined, neither: undefined };
}

export const TimeLockIntent: MessageFns<TimeLockIntent> = {
  encode(message: TimeLockIntent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.absolute !== undefined) {
      TimeLockRangeAbsolute.encode(message.absolute, writer.uint32(10).fork()).join();
    }
    if (message.relative !== undefined) {
      TimeLockRangeRelative.encode(message.relative, writer.uint32(18).fork()).join();
    }
    if (message.absoluteAndRelative !== undefined) {
      TimeLockRangeAbsoluteAndRelative.encode(message.absoluteAndRelative, writer.uint32(26).fork()).join();
    }
    if (message.neither !== undefined) {
      TimeLockRangeNeither.encode(message.neither, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockIntent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.absolute = TimeLockRangeAbsolute.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.relative = TimeLockRangeRelative.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.absoluteAndRelative = TimeLockRangeAbsoluteAndRelative.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.neither = TimeLockRangeNeither.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeLockIntent {
    return {
      absolute: isSet(object.absolute) ? TimeLockRangeAbsolute.fromJSON(object.absolute) : undefined,
      relative: isSet(object.relative) ? TimeLockRangeRelative.fromJSON(object.relative) : undefined,
      absoluteAndRelative: isSet(object.absoluteAndRelative)
        ? TimeLockRangeAbsoluteAndRelative.fromJSON(object.absoluteAndRelative)
        : undefined,
      neither: isSet(object.neither) ? TimeLockRangeNeither.fromJSON(object.neither) : undefined,
    };
  },

  toJSON(message: TimeLockIntent): unknown {
    const obj: any = {};
    if (message.absolute !== undefined) {
      obj.absolute = TimeLockRangeAbsolute.toJSON(message.absolute);
    }
    if (message.relative !== undefined) {
      obj.relative = TimeLockRangeRelative.toJSON(message.relative);
    }
    if (message.absoluteAndRelative !== undefined) {
      obj.absoluteAndRelative = TimeLockRangeAbsoluteAndRelative.toJSON(message.absoluteAndRelative);
    }
    if (message.neither !== undefined) {
      obj.neither = TimeLockRangeNeither.toJSON(message.neither);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeLockIntent>, I>>(base?: I): TimeLockIntent {
    return TimeLockIntent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeLockIntent>, I>>(object: I): TimeLockIntent {
    const message = createBaseTimeLockIntent();
    message.absolute = (object.absolute !== undefined && object.absolute !== null)
      ? TimeLockRangeAbsolute.fromPartial(object.absolute)
      : undefined;
    message.relative = (object.relative !== undefined && object.relative !== null)
      ? TimeLockRangeRelative.fromPartial(object.relative)
      : undefined;
    message.absoluteAndRelative = (object.absoluteAndRelative !== undefined && object.absoluteAndRelative !== null)
      ? TimeLockRangeAbsoluteAndRelative.fromPartial(object.absoluteAndRelative)
      : undefined;
    message.neither = (object.neither !== undefined && object.neither !== null)
      ? TimeLockRangeNeither.fromPartial(object.neither)
      : undefined;
    return message;
  },
};

function createBaseTimeLockRangeNeither(): TimeLockRangeNeither {
  return {};
}

export const TimeLockRangeNeither: MessageFns<TimeLockRangeNeither> = {
  encode(_: TimeLockRangeNeither, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockRangeNeither {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockRangeNeither();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TimeLockRangeNeither {
    return {};
  },

  toJSON(_: TimeLockRangeNeither): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeLockRangeNeither>, I>>(base?: I): TimeLockRangeNeither {
    return TimeLockRangeNeither.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeLockRangeNeither>, I>>(_: I): TimeLockRangeNeither {
    const message = createBaseTimeLockRangeNeither();
    return message;
  },
};

function createBaseTimeLockRangeAbsoluteAndRelative(): TimeLockRangeAbsoluteAndRelative {
  return { absolute: undefined, relative: undefined };
}

export const TimeLockRangeAbsoluteAndRelative: MessageFns<TimeLockRangeAbsoluteAndRelative> = {
  encode(message: TimeLockRangeAbsoluteAndRelative, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.absolute !== undefined) {
      TimeLockRangeAbsolute.encode(message.absolute, writer.uint32(10).fork()).join();
    }
    if (message.relative !== undefined) {
      TimeLockRangeRelative.encode(message.relative, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockRangeAbsoluteAndRelative {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockRangeAbsoluteAndRelative();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.absolute = TimeLockRangeAbsolute.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.relative = TimeLockRangeRelative.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeLockRangeAbsoluteAndRelative {
    return {
      absolute: isSet(object.absolute) ? TimeLockRangeAbsolute.fromJSON(object.absolute) : undefined,
      relative: isSet(object.relative) ? TimeLockRangeRelative.fromJSON(object.relative) : undefined,
    };
  },

  toJSON(message: TimeLockRangeAbsoluteAndRelative): unknown {
    const obj: any = {};
    if (message.absolute !== undefined) {
      obj.absolute = TimeLockRangeAbsolute.toJSON(message.absolute);
    }
    if (message.relative !== undefined) {
      obj.relative = TimeLockRangeRelative.toJSON(message.relative);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeLockRangeAbsoluteAndRelative>, I>>(
    base?: I,
  ): TimeLockRangeAbsoluteAndRelative {
    return TimeLockRangeAbsoluteAndRelative.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeLockRangeAbsoluteAndRelative>, I>>(
    object: I,
  ): TimeLockRangeAbsoluteAndRelative {
    const message = createBaseTimeLockRangeAbsoluteAndRelative();
    message.absolute = (object.absolute !== undefined && object.absolute !== null)
      ? TimeLockRangeAbsolute.fromPartial(object.absolute)
      : undefined;
    message.relative = (object.relative !== undefined && object.relative !== null)
      ? TimeLockRangeRelative.fromPartial(object.relative)
      : undefined;
    return message;
  },
};

function createBaseTimeLockRangeAbsolute(): TimeLockRangeAbsolute {
  return { min: undefined, max: undefined };
}

export const TimeLockRangeAbsolute: MessageFns<TimeLockRangeAbsolute> = {
  encode(message: TimeLockRangeAbsolute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      BlockHeight.encode(message.min, writer.uint32(10).fork()).join();
    }
    if (message.max !== undefined) {
      BlockHeight.encode(message.max, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockRangeAbsolute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockRangeAbsolute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.min = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeLockRangeAbsolute {
    return {
      min: isSet(object.min) ? BlockHeight.fromJSON(object.min) : undefined,
      max: isSet(object.max) ? BlockHeight.fromJSON(object.max) : undefined,
    };
  },

  toJSON(message: TimeLockRangeAbsolute): unknown {
    const obj: any = {};
    if (message.min !== undefined) {
      obj.min = BlockHeight.toJSON(message.min);
    }
    if (message.max !== undefined) {
      obj.max = BlockHeight.toJSON(message.max);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeLockRangeAbsolute>, I>>(base?: I): TimeLockRangeAbsolute {
    return TimeLockRangeAbsolute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeLockRangeAbsolute>, I>>(object: I): TimeLockRangeAbsolute {
    const message = createBaseTimeLockRangeAbsolute();
    message.min = (object.min !== undefined && object.min !== null) ? BlockHeight.fromPartial(object.min) : undefined;
    message.max = (object.max !== undefined && object.max !== null) ? BlockHeight.fromPartial(object.max) : undefined;
    return message;
  },
};

function createBaseTimeLockRangeRelative(): TimeLockRangeRelative {
  return { min: undefined, max: undefined };
}

export const TimeLockRangeRelative: MessageFns<TimeLockRangeRelative> = {
  encode(message: TimeLockRangeRelative, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== undefined) {
      BlockHeightDelta.encode(message.min, writer.uint32(10).fork()).join();
    }
    if (message.max !== undefined) {
      BlockHeightDelta.encode(message.max, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeLockRangeRelative {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeLockRangeRelative();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.min = BlockHeightDelta.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.max = BlockHeightDelta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeLockRangeRelative {
    return {
      min: isSet(object.min) ? BlockHeightDelta.fromJSON(object.min) : undefined,
      max: isSet(object.max) ? BlockHeightDelta.fromJSON(object.max) : undefined,
    };
  },

  toJSON(message: TimeLockRangeRelative): unknown {
    const obj: any = {};
    if (message.min !== undefined) {
      obj.min = BlockHeightDelta.toJSON(message.min);
    }
    if (message.max !== undefined) {
      obj.max = BlockHeightDelta.toJSON(message.max);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeLockRangeRelative>, I>>(base?: I): TimeLockRangeRelative {
    return TimeLockRangeRelative.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeLockRangeRelative>, I>>(object: I): TimeLockRangeRelative {
    const message = createBaseTimeLockRangeRelative();
    message.min = (object.min !== undefined && object.min !== null)
      ? BlockHeightDelta.fromPartial(object.min)
      : undefined;
    message.max = (object.max !== undefined && object.max !== null)
      ? BlockHeightDelta.fromPartial(object.max)
      : undefined;
    return message;
  },
};

function createBaseLock(): Lock {
  return { keysRequired: 0, schnorrPubkeys: [] };
}

export const Lock: MessageFns<Lock> = {
  encode(message: Lock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keysRequired !== 0) {
      writer.uint32(8).uint32(message.keysRequired);
    }
    for (const v of message.schnorrPubkeys) {
      SchnorrPubkey.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keysRequired = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schnorrPubkeys.push(SchnorrPubkey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lock {
    return {
      keysRequired: isSet(object.keysRequired) ? globalThis.Number(object.keysRequired) : 0,
      schnorrPubkeys: globalThis.Array.isArray(object?.schnorrPubkeys)
        ? object.schnorrPubkeys.map((e: any) => SchnorrPubkey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Lock): unknown {
    const obj: any = {};
    if (message.keysRequired !== 0) {
      obj.keysRequired = Math.round(message.keysRequired);
    }
    if (message.schnorrPubkeys?.length) {
      obj.schnorrPubkeys = message.schnorrPubkeys.map((e) => SchnorrPubkey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Lock>, I>>(base?: I): Lock {
    return Lock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Lock>, I>>(object: I): Lock {
    const message = createBaseLock();
    message.keysRequired = object.keysRequired ?? 0;
    message.schnorrPubkeys = object.schnorrPubkeys?.map((e) => SchnorrPubkey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseName(): Name {
  return { first: undefined, last: undefined };
}

export const Name: MessageFns<Name> = {
  encode(message: Name, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.first !== undefined) {
      Hash.encode(message.first, writer.uint32(10).fork()).join();
    }
    if (message.last !== undefined) {
      Hash.encode(message.last, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Name {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.first = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last = Hash.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Name {
    return {
      first: isSet(object.first) ? Hash.fromJSON(object.first) : undefined,
      last: isSet(object.last) ? Hash.fromJSON(object.last) : undefined,
    };
  },

  toJSON(message: Name): unknown {
    const obj: any = {};
    if (message.first !== undefined) {
      obj.first = Hash.toJSON(message.first);
    }
    if (message.last !== undefined) {
      obj.last = Hash.toJSON(message.last);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Name>, I>>(base?: I): Name {
    return Name.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Name>, I>>(object: I): Name {
    const message = createBaseName();
    message.first = (object.first !== undefined && object.first !== null) ? Hash.fromPartial(object.first) : undefined;
    message.last = (object.last !== undefined && object.last !== null) ? Hash.fromPartial(object.last) : undefined;
    return message;
  },
};

function createBaseNote(): Note {
  return {
    originPage: undefined,
    timelock: undefined,
    name: undefined,
    lock: undefined,
    source: undefined,
    assets: undefined,
    version: undefined,
  };
}

export const Note: MessageFns<Note> = {
  encode(message: Note, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originPage !== undefined) {
      BlockHeight.encode(message.originPage, writer.uint32(10).fork()).join();
    }
    if (message.timelock !== undefined) {
      TimeLockIntent.encode(message.timelock, writer.uint32(18).fork()).join();
    }
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(26).fork()).join();
    }
    if (message.lock !== undefined) {
      Lock.encode(message.lock, writer.uint32(34).fork()).join();
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(42).fork()).join();
    }
    if (message.assets !== undefined) {
      Nicks.encode(message.assets, writer.uint32(50).fork()).join();
    }
    if (message.version !== undefined) {
      NoteVersion.encode(message.version, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Note {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.originPage = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timelock = TimeLockIntent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lock = Lock.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assets = Nicks.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.version = NoteVersion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Note {
    return {
      originPage: isSet(object.originPage) ? BlockHeight.fromJSON(object.originPage) : undefined,
      timelock: isSet(object.timelock) ? TimeLockIntent.fromJSON(object.timelock) : undefined,
      name: isSet(object.name) ? Name.fromJSON(object.name) : undefined,
      lock: isSet(object.lock) ? Lock.fromJSON(object.lock) : undefined,
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      assets: isSet(object.assets) ? Nicks.fromJSON(object.assets) : undefined,
      version: isSet(object.version) ? NoteVersion.fromJSON(object.version) : undefined,
    };
  },

  toJSON(message: Note): unknown {
    const obj: any = {};
    if (message.originPage !== undefined) {
      obj.originPage = BlockHeight.toJSON(message.originPage);
    }
    if (message.timelock !== undefined) {
      obj.timelock = TimeLockIntent.toJSON(message.timelock);
    }
    if (message.name !== undefined) {
      obj.name = Name.toJSON(message.name);
    }
    if (message.lock !== undefined) {
      obj.lock = Lock.toJSON(message.lock);
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.assets !== undefined) {
      obj.assets = Nicks.toJSON(message.assets);
    }
    if (message.version !== undefined) {
      obj.version = NoteVersion.toJSON(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Note>, I>>(base?: I): Note {
    return Note.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Note>, I>>(object: I): Note {
    const message = createBaseNote();
    message.originPage = (object.originPage !== undefined && object.originPage !== null)
      ? BlockHeight.fromPartial(object.originPage)
      : undefined;
    message.timelock = (object.timelock !== undefined && object.timelock !== null)
      ? TimeLockIntent.fromPartial(object.timelock)
      : undefined;
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.lock = (object.lock !== undefined && object.lock !== null) ? Lock.fromPartial(object.lock) : undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.assets = (object.assets !== undefined && object.assets !== null)
      ? Nicks.fromPartial(object.assets)
      : undefined;
    message.version = (object.version !== undefined && object.version !== null)
      ? NoteVersion.fromPartial(object.version)
      : undefined;
    return message;
  },
};

function createBaseSignature(): Signature {
  return { entries: [] };
}

export const Signature: MessageFns<Signature> = {
  encode(message: Signature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      SignatureEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(SignatureEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => SignatureEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => SignatureEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signature>, I>>(base?: I): Signature {
    return Signature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signature>, I>>(object: I): Signature {
    const message = createBaseSignature();
    message.entries = object.entries?.map((e) => SignatureEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSignatureEntry(): SignatureEntry {
  return { schnorrPubkey: undefined, signature: undefined };
}

export const SignatureEntry: MessageFns<SignatureEntry> = {
  encode(message: SignatureEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schnorrPubkey !== undefined) {
      SchnorrPubkey.encode(message.schnorrPubkey, writer.uint32(10).fork()).join();
    }
    if (message.signature !== undefined) {
      SchnorrSignature.encode(message.signature, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schnorrPubkey = SchnorrPubkey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = SchnorrSignature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureEntry {
    return {
      schnorrPubkey: isSet(object.schnorrPubkey) ? SchnorrPubkey.fromJSON(object.schnorrPubkey) : undefined,
      signature: isSet(object.signature) ? SchnorrSignature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: SignatureEntry): unknown {
    const obj: any = {};
    if (message.schnorrPubkey !== undefined) {
      obj.schnorrPubkey = SchnorrPubkey.toJSON(message.schnorrPubkey);
    }
    if (message.signature !== undefined) {
      obj.signature = SchnorrSignature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignatureEntry>, I>>(base?: I): SignatureEntry {
    return SignatureEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignatureEntry>, I>>(object: I): SignatureEntry {
    const message = createBaseSignatureEntry();
    message.schnorrPubkey = (object.schnorrPubkey !== undefined && object.schnorrPubkey !== null)
      ? SchnorrPubkey.fromPartial(object.schnorrPubkey)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? SchnorrSignature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseSchnorrSignature(): SchnorrSignature {
  return { chal: undefined, sig: undefined };
}

export const SchnorrSignature: MessageFns<SchnorrSignature> = {
  encode(message: SchnorrSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chal !== undefined) {
      EightBelt.encode(message.chal, writer.uint32(10).fork()).join();
    }
    if (message.sig !== undefined) {
      EightBelt.encode(message.sig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchnorrSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchnorrSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chal = EightBelt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sig = EightBelt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchnorrSignature {
    return {
      chal: isSet(object.chal) ? EightBelt.fromJSON(object.chal) : undefined,
      sig: isSet(object.sig) ? EightBelt.fromJSON(object.sig) : undefined,
    };
  },

  toJSON(message: SchnorrSignature): unknown {
    const obj: any = {};
    if (message.chal !== undefined) {
      obj.chal = EightBelt.toJSON(message.chal);
    }
    if (message.sig !== undefined) {
      obj.sig = EightBelt.toJSON(message.sig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SchnorrSignature>, I>>(base?: I): SchnorrSignature {
    return SchnorrSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SchnorrSignature>, I>>(object: I): SchnorrSignature {
    const message = createBaseSchnorrSignature();
    message.chal = (object.chal !== undefined && object.chal !== null) ? EightBelt.fromPartial(object.chal) : undefined;
    message.sig = (object.sig !== undefined && object.sig !== null) ? EightBelt.fromPartial(object.sig) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
