// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: nockchain/common/v2/blockchain.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  Name,
  Note as Note1,
  SchnorrSignature,
  Signature,
  Source,
  TimeLockRangeAbsolute,
  TimeLockRangeRelative,
} from "../v1/blockchain";
import { PageResponse } from "../v1/pagination";
import { BlockHeight, Hash, Nicks, NoteVersion, SchnorrPubkey } from "../v1/primitives";

export const protobufPackage = "nockchain.common.v2";

export interface Balance {
  notes: BalanceEntry[];
  height: BlockHeight | undefined;
  blockId?: Hash | undefined;
  page: PageResponse | undefined;
}

export interface BalanceEntry {
  name: Name | undefined;
  note: Note | undefined;
}

export interface Note {
  legacy?: Note1 | undefined;
  v1?: NoteV1 | undefined;
}

export interface NoteV1 {
  version: NoteVersion | undefined;
  originPage: BlockHeight | undefined;
  name: Name | undefined;
  noteData: NoteData | undefined;
  assets: Nicks | undefined;
}

export interface NoteData {
  entries: NoteDataEntry[];
}

export interface NoteDataEntry {
  key: string;
  /** jammed noun bytes */
  blob: Buffer;
}

export interface RawTransaction {
  version: NoteVersion | undefined;
  id: Hash | undefined;
  spends: SpendEntry[];
}

export interface SpendEntry {
  name: Name | undefined;
  spend: Spend | undefined;
}

export interface Spend {
  legacy?: LegacySpend | undefined;
  witness?: WitnessSpend | undefined;
}

export interface LegacySpend {
  signature: Signature | undefined;
  seeds: Seed[];
  fee: Nicks | undefined;
}

export interface WitnessSpend {
  witness: Witness | undefined;
  seeds: Seed[];
  fee: Nicks | undefined;
}

export interface Seed {
  /** Absent when the seed originates from a coinbase output. */
  outputSource: Source | undefined;
  lockRoot: Hash | undefined;
  noteData: NoteData | undefined;
  gift: Nicks | undefined;
  parentHash: Hash | undefined;
}

export interface Witness {
  lockMerkleProof: LockMerkleProof | undefined;
  pkhSignature:
    | PkhSignature
    | undefined;
  /** uint64 tim = 4; // reserved field, currently 0 */
  hax: HaxPreimage[];
}

export interface HaxPreimage {
  hash:
    | Hash
    | undefined;
  /** jammed noun bytes */
  value: Buffer;
}

export interface PkhSignature {
  entries: PkhSignatureEntry[];
}

export interface PkhSignatureEntry {
  hash: Hash | undefined;
  pubkey: SchnorrPubkey | undefined;
  signature: SchnorrSignature | undefined;
}

export interface LockMerkleProof {
  spendCondition: SpendCondition | undefined;
  axis: string;
  proof: MerkleProof | undefined;
}

export interface SpendCondition {
  primitives: LockPrimitive[];
}

export interface LockPrimitive {
  pkh?: PkhLock | undefined;
  tim?: LockTim | undefined;
  hax?: HaxLock | undefined;
  burn?: BurnLock | undefined;
}

export interface PkhLock {
  m: string;
  hashes: Hash[];
}

export interface LockTim {
  rel: TimeLockRangeRelative | undefined;
  abs: TimeLockRangeAbsolute | undefined;
}

export interface HaxLock {
  hashes: Hash[];
}

export interface BurnLock {
}

export interface MerkleProof {
  root: Hash | undefined;
  path: Hash[];
}

function createBaseBalance(): Balance {
  return { notes: [], height: undefined, blockId: undefined, page: undefined };
}

export const Balance: MessageFns<Balance> = {
  encode(message: Balance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notes) {
      BalanceEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.height !== undefined) {
      BlockHeight.encode(message.height, writer.uint32(18).fork()).join();
    }
    if (message.blockId !== undefined) {
      Hash.encode(message.blockId, writer.uint32(26).fork()).join();
    }
    if (message.page !== undefined) {
      PageResponse.encode(message.page, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Balance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notes.push(BalanceEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.height = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockId = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.page = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Balance>): Balance {
    return Balance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Balance>): Balance {
    const message = createBaseBalance();
    message.notes = object.notes?.map((e) => BalanceEntry.fromPartial(e)) || [];
    message.height = (object.height !== undefined && object.height !== null)
      ? BlockHeight.fromPartial(object.height)
      : undefined;
    message.blockId = (object.blockId !== undefined && object.blockId !== null)
      ? Hash.fromPartial(object.blockId)
      : undefined;
    message.page = (object.page !== undefined && object.page !== null)
      ? PageResponse.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBaseBalanceEntry(): BalanceEntry {
  return { name: undefined, note: undefined };
}

export const BalanceEntry: MessageFns<BalanceEntry> = {
  encode(message: BalanceEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BalanceEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BalanceEntry>): BalanceEntry {
    return BalanceEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalanceEntry>): BalanceEntry {
    const message = createBaseBalanceEntry();
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    return message;
  },
};

function createBaseNote(): Note {
  return { legacy: undefined, v1: undefined };
}

export const Note: MessageFns<Note> = {
  encode(message: Note, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.legacy !== undefined) {
      Note1.encode(message.legacy, writer.uint32(10).fork()).join();
    }
    if (message.v1 !== undefined) {
      NoteV1.encode(message.v1, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Note {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.legacy = Note1.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.v1 = NoteV1.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Note>): Note {
    return Note.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Note>): Note {
    const message = createBaseNote();
    message.legacy = (object.legacy !== undefined && object.legacy !== null)
      ? Note1.fromPartial(object.legacy)
      : undefined;
    message.v1 = (object.v1 !== undefined && object.v1 !== null) ? NoteV1.fromPartial(object.v1) : undefined;
    return message;
  },
};

function createBaseNoteV1(): NoteV1 {
  return { version: undefined, originPage: undefined, name: undefined, noteData: undefined, assets: undefined };
}

export const NoteV1: MessageFns<NoteV1> = {
  encode(message: NoteV1, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      NoteVersion.encode(message.version, writer.uint32(10).fork()).join();
    }
    if (message.originPage !== undefined) {
      BlockHeight.encode(message.originPage, writer.uint32(18).fork()).join();
    }
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(26).fork()).join();
    }
    if (message.noteData !== undefined) {
      NoteData.encode(message.noteData, writer.uint32(34).fork()).join();
    }
    if (message.assets !== undefined) {
      Nicks.encode(message.assets, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteV1 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteV1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = NoteVersion.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originPage = BlockHeight.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.noteData = NoteData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assets = Nicks.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NoteV1>): NoteV1 {
    return NoteV1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoteV1>): NoteV1 {
    const message = createBaseNoteV1();
    message.version = (object.version !== undefined && object.version !== null)
      ? NoteVersion.fromPartial(object.version)
      : undefined;
    message.originPage = (object.originPage !== undefined && object.originPage !== null)
      ? BlockHeight.fromPartial(object.originPage)
      : undefined;
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.noteData = (object.noteData !== undefined && object.noteData !== null)
      ? NoteData.fromPartial(object.noteData)
      : undefined;
    message.assets = (object.assets !== undefined && object.assets !== null)
      ? Nicks.fromPartial(object.assets)
      : undefined;
    return message;
  },
};

function createBaseNoteData(): NoteData {
  return { entries: [] };
}

export const NoteData: MessageFns<NoteData> = {
  encode(message: NoteData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      NoteDataEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(NoteDataEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NoteData>): NoteData {
    return NoteData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoteData>): NoteData {
    const message = createBaseNoteData();
    message.entries = object.entries?.map((e) => NoteDataEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNoteDataEntry(): NoteDataEntry {
  return { key: "", blob: Buffer.alloc(0) };
}

export const NoteDataEntry: MessageFns<NoteDataEntry> = {
  encode(message: NoteDataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.blob.length !== 0) {
      writer.uint32(18).bytes(message.blob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoteDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blob = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<NoteDataEntry>): NoteDataEntry {
    return NoteDataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoteDataEntry>): NoteDataEntry {
    const message = createBaseNoteDataEntry();
    message.key = object.key ?? "";
    message.blob = object.blob ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseRawTransaction(): RawTransaction {
  return { version: undefined, id: undefined, spends: [] };
}

export const RawTransaction: MessageFns<RawTransaction> = {
  encode(message: RawTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      NoteVersion.encode(message.version, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      Hash.encode(message.id, writer.uint32(18).fork()).join();
    }
    for (const v of message.spends) {
      SpendEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = NoteVersion.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.spends.push(SpendEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RawTransaction>): RawTransaction {
    return RawTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawTransaction>): RawTransaction {
    const message = createBaseRawTransaction();
    message.version = (object.version !== undefined && object.version !== null)
      ? NoteVersion.fromPartial(object.version)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? Hash.fromPartial(object.id) : undefined;
    message.spends = object.spends?.map((e) => SpendEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpendEntry(): SpendEntry {
  return { name: undefined, spend: undefined };
}

export const SpendEntry: MessageFns<SpendEntry> = {
  encode(message: SpendEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      Name.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.spend !== undefined) {
      Spend.encode(message.spend, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpendEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = Name.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.spend = Spend.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SpendEntry>): SpendEntry {
    return SpendEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpendEntry>): SpendEntry {
    const message = createBaseSpendEntry();
    message.name = (object.name !== undefined && object.name !== null) ? Name.fromPartial(object.name) : undefined;
    message.spend = (object.spend !== undefined && object.spend !== null) ? Spend.fromPartial(object.spend) : undefined;
    return message;
  },
};

function createBaseSpend(): Spend {
  return { legacy: undefined, witness: undefined };
}

export const Spend: MessageFns<Spend> = {
  encode(message: Spend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.legacy !== undefined) {
      LegacySpend.encode(message.legacy, writer.uint32(10).fork()).join();
    }
    if (message.witness !== undefined) {
      WitnessSpend.encode(message.witness, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.legacy = LegacySpend.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.witness = WitnessSpend.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Spend>): Spend {
    return Spend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Spend>): Spend {
    const message = createBaseSpend();
    message.legacy = (object.legacy !== undefined && object.legacy !== null)
      ? LegacySpend.fromPartial(object.legacy)
      : undefined;
    message.witness = (object.witness !== undefined && object.witness !== null)
      ? WitnessSpend.fromPartial(object.witness)
      : undefined;
    return message;
  },
};

function createBaseLegacySpend(): LegacySpend {
  return { signature: undefined, seeds: [], fee: undefined };
}

export const LegacySpend: MessageFns<LegacySpend> = {
  encode(message: LegacySpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(10).fork()).join();
    }
    for (const v of message.seeds) {
      Seed.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.fee !== undefined) {
      Nicks.encode(message.fee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LegacySpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLegacySpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seeds.push(Seed.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fee = Nicks.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LegacySpend>): LegacySpend {
    return LegacySpend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LegacySpend>): LegacySpend {
    const message = createBaseLegacySpend();
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    message.seeds = object.seeds?.map((e) => Seed.fromPartial(e)) || [];
    message.fee = (object.fee !== undefined && object.fee !== null) ? Nicks.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseWitnessSpend(): WitnessSpend {
  return { witness: undefined, seeds: [], fee: undefined };
}

export const WitnessSpend: MessageFns<WitnessSpend> = {
  encode(message: WitnessSpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.witness !== undefined) {
      Witness.encode(message.witness, writer.uint32(10).fork()).join();
    }
    for (const v of message.seeds) {
      Seed.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.fee !== undefined) {
      Nicks.encode(message.fee, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WitnessSpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitnessSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.witness = Witness.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.seeds.push(Seed.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fee = Nicks.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WitnessSpend>): WitnessSpend {
    return WitnessSpend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WitnessSpend>): WitnessSpend {
    const message = createBaseWitnessSpend();
    message.witness = (object.witness !== undefined && object.witness !== null)
      ? Witness.fromPartial(object.witness)
      : undefined;
    message.seeds = object.seeds?.map((e) => Seed.fromPartial(e)) || [];
    message.fee = (object.fee !== undefined && object.fee !== null) ? Nicks.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseSeed(): Seed {
  return { outputSource: undefined, lockRoot: undefined, noteData: undefined, gift: undefined, parentHash: undefined };
}

export const Seed: MessageFns<Seed> = {
  encode(message: Seed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputSource !== undefined) {
      Source.encode(message.outputSource, writer.uint32(10).fork()).join();
    }
    if (message.lockRoot !== undefined) {
      Hash.encode(message.lockRoot, writer.uint32(18).fork()).join();
    }
    if (message.noteData !== undefined) {
      NoteData.encode(message.noteData, writer.uint32(26).fork()).join();
    }
    if (message.gift !== undefined) {
      Nicks.encode(message.gift, writer.uint32(34).fork()).join();
    }
    if (message.parentHash !== undefined) {
      Hash.encode(message.parentHash, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Seed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputSource = Source.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lockRoot = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.noteData = NoteData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gift = Nicks.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parentHash = Hash.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Seed>): Seed {
    return Seed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Seed>): Seed {
    const message = createBaseSeed();
    message.outputSource = (object.outputSource !== undefined && object.outputSource !== null)
      ? Source.fromPartial(object.outputSource)
      : undefined;
    message.lockRoot = (object.lockRoot !== undefined && object.lockRoot !== null)
      ? Hash.fromPartial(object.lockRoot)
      : undefined;
    message.noteData = (object.noteData !== undefined && object.noteData !== null)
      ? NoteData.fromPartial(object.noteData)
      : undefined;
    message.gift = (object.gift !== undefined && object.gift !== null) ? Nicks.fromPartial(object.gift) : undefined;
    message.parentHash = (object.parentHash !== undefined && object.parentHash !== null)
      ? Hash.fromPartial(object.parentHash)
      : undefined;
    return message;
  },
};

function createBaseWitness(): Witness {
  return { lockMerkleProof: undefined, pkhSignature: undefined, hax: [] };
}

export const Witness: MessageFns<Witness> = {
  encode(message: Witness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lockMerkleProof !== undefined) {
      LockMerkleProof.encode(message.lockMerkleProof, writer.uint32(10).fork()).join();
    }
    if (message.pkhSignature !== undefined) {
      PkhSignature.encode(message.pkhSignature, writer.uint32(18).fork()).join();
    }
    for (const v of message.hax) {
      HaxPreimage.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Witness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lockMerkleProof = LockMerkleProof.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pkhSignature = PkhSignature.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hax.push(HaxPreimage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Witness>): Witness {
    return Witness.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Witness>): Witness {
    const message = createBaseWitness();
    message.lockMerkleProof = (object.lockMerkleProof !== undefined && object.lockMerkleProof !== null)
      ? LockMerkleProof.fromPartial(object.lockMerkleProof)
      : undefined;
    message.pkhSignature = (object.pkhSignature !== undefined && object.pkhSignature !== null)
      ? PkhSignature.fromPartial(object.pkhSignature)
      : undefined;
    message.hax = object.hax?.map((e) => HaxPreimage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHaxPreimage(): HaxPreimage {
  return { hash: undefined, value: Buffer.alloc(0) };
}

export const HaxPreimage: MessageFns<HaxPreimage> = {
  encode(message: HaxPreimage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== undefined) {
      Hash.encode(message.hash, writer.uint32(10).fork()).join();
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HaxPreimage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHaxPreimage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<HaxPreimage>): HaxPreimage {
    return HaxPreimage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HaxPreimage>): HaxPreimage {
    const message = createBaseHaxPreimage();
    message.hash = (object.hash !== undefined && object.hash !== null) ? Hash.fromPartial(object.hash) : undefined;
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePkhSignature(): PkhSignature {
  return { entries: [] };
}

export const PkhSignature: MessageFns<PkhSignature> = {
  encode(message: PkhSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      PkhSignatureEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PkhSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePkhSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(PkhSignatureEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PkhSignature>): PkhSignature {
    return PkhSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PkhSignature>): PkhSignature {
    const message = createBasePkhSignature();
    message.entries = object.entries?.map((e) => PkhSignatureEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBasePkhSignatureEntry(): PkhSignatureEntry {
  return { hash: undefined, pubkey: undefined, signature: undefined };
}

export const PkhSignatureEntry: MessageFns<PkhSignatureEntry> = {
  encode(message: PkhSignatureEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== undefined) {
      Hash.encode(message.hash, writer.uint32(10).fork()).join();
    }
    if (message.pubkey !== undefined) {
      SchnorrPubkey.encode(message.pubkey, writer.uint32(18).fork()).join();
    }
    if (message.signature !== undefined) {
      SchnorrSignature.encode(message.signature, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PkhSignatureEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePkhSignatureEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pubkey = SchnorrPubkey.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = SchnorrSignature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PkhSignatureEntry>): PkhSignatureEntry {
    return PkhSignatureEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PkhSignatureEntry>): PkhSignatureEntry {
    const message = createBasePkhSignatureEntry();
    message.hash = (object.hash !== undefined && object.hash !== null) ? Hash.fromPartial(object.hash) : undefined;
    message.pubkey = (object.pubkey !== undefined && object.pubkey !== null)
      ? SchnorrPubkey.fromPartial(object.pubkey)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? SchnorrSignature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseLockMerkleProof(): LockMerkleProof {
  return { spendCondition: undefined, axis: "0", proof: undefined };
}

export const LockMerkleProof: MessageFns<LockMerkleProof> = {
  encode(message: LockMerkleProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spendCondition !== undefined) {
      SpendCondition.encode(message.spendCondition, writer.uint32(10).fork()).join();
    }
    if (message.axis !== "0") {
      writer.uint32(16).uint64(message.axis);
    }
    if (message.proof !== undefined) {
      MerkleProof.encode(message.proof, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockMerkleProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockMerkleProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spendCondition = SpendCondition.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.axis = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proof = MerkleProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LockMerkleProof>): LockMerkleProof {
    return LockMerkleProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LockMerkleProof>): LockMerkleProof {
    const message = createBaseLockMerkleProof();
    message.spendCondition = (object.spendCondition !== undefined && object.spendCondition !== null)
      ? SpendCondition.fromPartial(object.spendCondition)
      : undefined;
    message.axis = object.axis ?? "0";
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? MerkleProof.fromPartial(object.proof)
      : undefined;
    return message;
  },
};

function createBaseSpendCondition(): SpendCondition {
  return { primitives: [] };
}

export const SpendCondition: MessageFns<SpendCondition> = {
  encode(message: SpendCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.primitives) {
      LockPrimitive.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpendCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primitives.push(LockPrimitive.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SpendCondition>): SpendCondition {
    return SpendCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpendCondition>): SpendCondition {
    const message = createBaseSpendCondition();
    message.primitives = object.primitives?.map((e) => LockPrimitive.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLockPrimitive(): LockPrimitive {
  return { pkh: undefined, tim: undefined, hax: undefined, burn: undefined };
}

export const LockPrimitive: MessageFns<LockPrimitive> = {
  encode(message: LockPrimitive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pkh !== undefined) {
      PkhLock.encode(message.pkh, writer.uint32(10).fork()).join();
    }
    if (message.tim !== undefined) {
      LockTim.encode(message.tim, writer.uint32(18).fork()).join();
    }
    if (message.hax !== undefined) {
      HaxLock.encode(message.hax, writer.uint32(26).fork()).join();
    }
    if (message.burn !== undefined) {
      BurnLock.encode(message.burn, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockPrimitive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockPrimitive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pkh = PkhLock.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tim = LockTim.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hax = HaxLock.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.burn = BurnLock.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LockPrimitive>): LockPrimitive {
    return LockPrimitive.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LockPrimitive>): LockPrimitive {
    const message = createBaseLockPrimitive();
    message.pkh = (object.pkh !== undefined && object.pkh !== null) ? PkhLock.fromPartial(object.pkh) : undefined;
    message.tim = (object.tim !== undefined && object.tim !== null) ? LockTim.fromPartial(object.tim) : undefined;
    message.hax = (object.hax !== undefined && object.hax !== null) ? HaxLock.fromPartial(object.hax) : undefined;
    message.burn = (object.burn !== undefined && object.burn !== null) ? BurnLock.fromPartial(object.burn) : undefined;
    return message;
  },
};

function createBasePkhLock(): PkhLock {
  return { m: "0", hashes: [] };
}

export const PkhLock: MessageFns<PkhLock> = {
  encode(message: PkhLock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.m !== "0") {
      writer.uint32(8).uint64(message.m);
    }
    for (const v of message.hashes) {
      Hash.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PkhLock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePkhLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.m = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hashes.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PkhLock>): PkhLock {
    return PkhLock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PkhLock>): PkhLock {
    const message = createBasePkhLock();
    message.m = object.m ?? "0";
    message.hashes = object.hashes?.map((e) => Hash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLockTim(): LockTim {
  return { rel: undefined, abs: undefined };
}

export const LockTim: MessageFns<LockTim> = {
  encode(message: LockTim, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rel !== undefined) {
      TimeLockRangeRelative.encode(message.rel, writer.uint32(10).fork()).join();
    }
    if (message.abs !== undefined) {
      TimeLockRangeAbsolute.encode(message.abs, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockTim {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockTim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rel = TimeLockRangeRelative.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.abs = TimeLockRangeAbsolute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LockTim>): LockTim {
    return LockTim.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LockTim>): LockTim {
    const message = createBaseLockTim();
    message.rel = (object.rel !== undefined && object.rel !== null)
      ? TimeLockRangeRelative.fromPartial(object.rel)
      : undefined;
    message.abs = (object.abs !== undefined && object.abs !== null)
      ? TimeLockRangeAbsolute.fromPartial(object.abs)
      : undefined;
    return message;
  },
};

function createBaseHaxLock(): HaxLock {
  return { hashes: [] };
}

export const HaxLock: MessageFns<HaxLock> = {
  encode(message: HaxLock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hashes) {
      Hash.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HaxLock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHaxLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hashes.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<HaxLock>): HaxLock {
    return HaxLock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HaxLock>): HaxLock {
    const message = createBaseHaxLock();
    message.hashes = object.hashes?.map((e) => Hash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBurnLock(): BurnLock {
  return {};
}

export const BurnLock: MessageFns<BurnLock> = {
  encode(_: BurnLock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BurnLock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBurnLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BurnLock>): BurnLock {
    return BurnLock.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BurnLock>): BurnLock {
    const message = createBaseBurnLock();
    return message;
  },
};

function createBaseMerkleProof(): MerkleProof {
  return { root: undefined, path: [] };
}

export const MerkleProof: MessageFns<MerkleProof> = {
  encode(message: MerkleProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.root !== undefined) {
      Hash.encode(message.root, writer.uint32(10).fork()).join();
    }
    for (const v of message.path) {
      Hash.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MerkleProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerkleProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.root = Hash.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MerkleProof>): MerkleProof {
    return MerkleProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MerkleProof>): MerkleProof {
    const message = createBaseMerkleProof();
    message.root = (object.root !== undefined && object.root !== null) ? Hash.fromPartial(object.root) : undefined;
    message.path = object.path?.map((e) => Hash.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
